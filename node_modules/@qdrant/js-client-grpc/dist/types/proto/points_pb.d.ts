import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { Value } from "./json_with_int_pb.js";
import { PayloadIndexParams, ShardKey } from "./collections_pb.js";
/**
 * @generated from enum qdrant.WriteOrderingType
 */
export declare enum WriteOrderingType {
    /**
     * Write operations may be reordered, works faster, default
     *
     * @generated from enum value: Weak = 0;
     */
    Weak = 0,
    /**
     * Write operations go through dynamically selected leader, may be inconsistent for a short period of time in case of leader change
     *
     * @generated from enum value: Medium = 1;
     */
    Medium = 1,
    /**
     * Write operations go through the permanent leader, consistent, but may be unavailable if leader is down
     *
     * @generated from enum value: Strong = 2;
     */
    Strong = 2
}
/**
 * @generated from enum qdrant.ReadConsistencyType
 */
export declare enum ReadConsistencyType {
    /**
     * Send request to all nodes and return points which are present on all of them
     *
     * @generated from enum value: All = 0;
     */
    All = 0,
    /**
     * Send requests to all nodes and return points which are present on majority of them
     *
     * @generated from enum value: Majority = 1;
     */
    Majority = 1,
    /**
     * Send requests to half + 1 nodes, return points which are present on all of them
     *
     * @generated from enum value: Quorum = 2;
     */
    Quorum = 2
}
/**
 * @generated from enum qdrant.FieldType
 */
export declare enum FieldType {
    /**
     * @generated from enum value: FieldTypeKeyword = 0;
     */
    FieldTypeKeyword = 0,
    /**
     * @generated from enum value: FieldTypeInteger = 1;
     */
    FieldTypeInteger = 1,
    /**
     * @generated from enum value: FieldTypeFloat = 2;
     */
    FieldTypeFloat = 2,
    /**
     * @generated from enum value: FieldTypeGeo = 3;
     */
    FieldTypeGeo = 3,
    /**
     * @generated from enum value: FieldTypeText = 4;
     */
    FieldTypeText = 4,
    /**
     * @generated from enum value: FieldTypeBool = 5;
     */
    FieldTypeBool = 5,
    /**
     * @generated from enum value: FieldTypeDatetime = 6;
     */
    FieldTypeDatetime = 6,
    /**
     * @generated from enum value: FieldTypeUuid = 7;
     */
    FieldTypeUuid = 7
}
/**
 * @generated from enum qdrant.Direction
 */
export declare enum Direction {
    /**
     * @generated from enum value: Asc = 0;
     */
    Asc = 0,
    /**
     * @generated from enum value: Desc = 1;
     */
    Desc = 1
}
/**
 * How to use positive and negative vectors to find the results, default is `AverageVector`.
 *
 * @generated from enum qdrant.RecommendStrategy
 */
export declare enum RecommendStrategy {
    /**
     * Average positive and negative vectors and create a single query with the formula
     * `query = avg_pos + avg_pos - avg_neg`. Then performs normal search.
     *
     * @generated from enum value: AverageVector = 0;
     */
    AverageVector = 0,
    /**
     * Uses custom search objective. Each candidate is compared against all
     * examples, its score is then chosen from the `max(max_pos_score, max_neg_score)`.
     * If the `max_neg_score` is chosen then it is squared and negated.
     *
     * @generated from enum value: BestScore = 1;
     */
    BestScore = 1,
    /**
     * Uses custom search objective. Compares against all inputs, sums all the scores.
     * Scores against positive vectors are added, against negatives are subtracted.
     *
     * @generated from enum value: SumScores = 2;
     */
    SumScores = 2
}
/**
 * @generated from enum qdrant.Fusion
 */
export declare enum Fusion {
    /**
     * Reciprocal Rank Fusion
     *
     * @generated from enum value: RRF = 0;
     */
    RRF = 0,
    /**
     * Distribution-Based Score Fusion
     *
     * @generated from enum value: DBSF = 1;
     */
    DBSF = 1
}
/**
 * Sample points from the collection
 *
 * Available sampling methods:
 *
 * * `random` - Random sampling
 *
 * @generated from enum qdrant.Sample
 */
export declare enum Sample {
    /**
     * @generated from enum value: Random = 0;
     */
    Random = 0
}
/**
 * @generated from enum qdrant.UpdateStatus
 */
export declare enum UpdateStatus {
    /**
     * @generated from enum value: UnknownUpdateStatus = 0;
     */
    UnknownUpdateStatus = 0,
    /**
     * Update is received, but not processed yet
     *
     * @generated from enum value: Acknowledged = 1;
     */
    Acknowledged = 1,
    /**
     * Update is applied and ready for search
     *
     * @generated from enum value: Completed = 2;
     */
    Completed = 2,
    /**
     * Internal: update is rejected due to an outdated clock
     *
     * @generated from enum value: ClockRejected = 3;
     */
    ClockRejected = 3
}
/**
 * @generated from message qdrant.WriteOrdering
 */
export declare class WriteOrdering extends Message<WriteOrdering> {
    /**
     * Write ordering guarantees
     *
     * @generated from field: qdrant.WriteOrderingType type = 1;
     */
    type: WriteOrderingType;
    constructor(data?: PartialMessage<WriteOrdering>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.WriteOrdering";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WriteOrdering;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WriteOrdering;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WriteOrdering;
    static equals(a: WriteOrdering | PlainMessage<WriteOrdering> | undefined, b: WriteOrdering | PlainMessage<WriteOrdering> | undefined): boolean;
}
/**
 * @generated from message qdrant.ReadConsistency
 */
export declare class ReadConsistency extends Message<ReadConsistency> {
    /**
     * @generated from oneof qdrant.ReadConsistency.value
     */
    value: {
        /**
         * Common read consistency configurations
         *
         * @generated from field: qdrant.ReadConsistencyType type = 1;
         */
        value: ReadConsistencyType;
        case: "type";
    } | {
        /**
         * Send request to a specified number of nodes, and return points which are present on all of them
         *
         * @generated from field: uint64 factor = 2;
         */
        value: bigint;
        case: "factor";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<ReadConsistency>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ReadConsistency";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadConsistency;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadConsistency;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadConsistency;
    static equals(a: ReadConsistency | PlainMessage<ReadConsistency> | undefined, b: ReadConsistency | PlainMessage<ReadConsistency> | undefined): boolean;
}
/**
 * @generated from message qdrant.PointId
 */
export declare class PointId extends Message<PointId> {
    /**
     * @generated from oneof qdrant.PointId.point_id_options
     */
    pointIdOptions: {
        /**
         * Numerical ID of the point
         *
         * @generated from field: uint64 num = 1;
         */
        value: bigint;
        case: "num";
    } | {
        /**
         * UUID
         *
         * @generated from field: string uuid = 2;
         */
        value: string;
        case: "uuid";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<PointId>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PointId";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointId;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointId;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointId;
    static equals(a: PointId | PlainMessage<PointId> | undefined, b: PointId | PlainMessage<PointId> | undefined): boolean;
}
/**
 * @generated from message qdrant.SparseIndices
 */
export declare class SparseIndices extends Message<SparseIndices> {
    /**
     * @generated from field: repeated uint32 data = 1;
     */
    data: number[];
    constructor(data?: PartialMessage<SparseIndices>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SparseIndices";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SparseIndices;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SparseIndices;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SparseIndices;
    static equals(a: SparseIndices | PlainMessage<SparseIndices> | undefined, b: SparseIndices | PlainMessage<SparseIndices> | undefined): boolean;
}
/**
 * @generated from message qdrant.Document
 */
export declare class Document extends Message<Document> {
    /**
     * Text of the document
     *
     * @generated from field: string text = 1;
     */
    text: string;
    /**
     * Model name
     *
     * @generated from field: string model = 3;
     */
    model: string;
    /**
     * Model options
     *
     * @generated from field: map<string, qdrant.Value> options = 4;
     */
    options: {
        [key: string]: Value;
    };
    constructor(data?: PartialMessage<Document>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.Document";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Document;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Document;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Document;
    static equals(a: Document | PlainMessage<Document> | undefined, b: Document | PlainMessage<Document> | undefined): boolean;
}
/**
 * @generated from message qdrant.Image
 */
export declare class Image extends Message<Image> {
    /**
     * Image data, either base64 encoded or URL
     *
     * @generated from field: qdrant.Value image = 1;
     */
    image?: Value;
    /**
     * Model name
     *
     * @generated from field: string model = 2;
     */
    model: string;
    /**
     * Model options
     *
     * @generated from field: map<string, qdrant.Value> options = 3;
     */
    options: {
        [key: string]: Value;
    };
    constructor(data?: PartialMessage<Image>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.Image";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Image;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Image;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Image;
    static equals(a: Image | PlainMessage<Image> | undefined, b: Image | PlainMessage<Image> | undefined): boolean;
}
/**
 * @generated from message qdrant.InferenceObject
 */
export declare class InferenceObject extends Message<InferenceObject> {
    /**
     * Object to infer
     *
     * @generated from field: qdrant.Value object = 1;
     */
    object?: Value;
    /**
     * Model name
     *
     * @generated from field: string model = 2;
     */
    model: string;
    /**
     * Model options
     *
     * @generated from field: map<string, qdrant.Value> options = 3;
     */
    options: {
        [key: string]: Value;
    };
    constructor(data?: PartialMessage<InferenceObject>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.InferenceObject";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InferenceObject;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InferenceObject;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InferenceObject;
    static equals(a: InferenceObject | PlainMessage<InferenceObject> | undefined, b: InferenceObject | PlainMessage<InferenceObject> | undefined): boolean;
}
/**
 * Legacy vector format, which determines the vector type by the configuration of its fields.
 *
 * @generated from message qdrant.Vector
 */
export declare class Vector extends Message<Vector> {
    /**
     * Vector data (flatten for multi vectors), deprecated
     *
     * @generated from field: repeated float data = 1;
     */
    data: number[];
    /**
     * Sparse indices for sparse vectors, deprecated
     *
     * @generated from field: optional qdrant.SparseIndices indices = 2;
     */
    indices?: SparseIndices;
    /**
     * Number of vectors per multi vector, deprecated
     *
     * @generated from field: optional uint32 vectors_count = 3;
     */
    vectorsCount?: number;
    /**
     * @generated from oneof qdrant.Vector.vector
     */
    vector: {
        /**
         * Dense vector
         *
         * @generated from field: qdrant.DenseVector dense = 101;
         */
        value: DenseVector;
        case: "dense";
    } | {
        /**
         * Sparse vector
         *
         * @generated from field: qdrant.SparseVector sparse = 102;
         */
        value: SparseVector;
        case: "sparse";
    } | {
        /**
         * Multi dense vector
         *
         * @generated from field: qdrant.MultiDenseVector multi_dense = 103;
         */
        value: MultiDenseVector;
        case: "multiDense";
    } | {
        /**
         * @generated from field: qdrant.Document document = 104;
         */
        value: Document;
        case: "document";
    } | {
        /**
         * @generated from field: qdrant.Image image = 105;
         */
        value: Image;
        case: "image";
    } | {
        /**
         * @generated from field: qdrant.InferenceObject object = 106;
         */
        value: InferenceObject;
        case: "object";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<Vector>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.Vector";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Vector;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Vector;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Vector;
    static equals(a: Vector | PlainMessage<Vector> | undefined, b: Vector | PlainMessage<Vector> | undefined): boolean;
}
/**
 * @generated from message qdrant.VectorOutput
 */
export declare class VectorOutput extends Message<VectorOutput> {
    /**
     * Vector data (flatten for multi vectors), deprecated
     *
     * @generated from field: repeated float data = 1;
     */
    data: number[];
    /**
     * Sparse indices for sparse vectors, deprecated
     *
     * @generated from field: optional qdrant.SparseIndices indices = 2;
     */
    indices?: SparseIndices;
    /**
     * Number of vectors per multi vector, deprecated
     *
     * @generated from field: optional uint32 vectors_count = 3;
     */
    vectorsCount?: number;
    /**
     * @generated from oneof qdrant.VectorOutput.vector
     */
    vector: {
        /**
         * Dense vector
         *
         * @generated from field: qdrant.DenseVector dense = 101;
         */
        value: DenseVector;
        case: "dense";
    } | {
        /**
         * Sparse vector
         *
         * @generated from field: qdrant.SparseVector sparse = 102;
         */
        value: SparseVector;
        case: "sparse";
    } | {
        /**
         * Multi dense vector
         *
         * @generated from field: qdrant.MultiDenseVector multi_dense = 103;
         */
        value: MultiDenseVector;
        case: "multiDense";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<VectorOutput>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.VectorOutput";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VectorOutput;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VectorOutput;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VectorOutput;
    static equals(a: VectorOutput | PlainMessage<VectorOutput> | undefined, b: VectorOutput | PlainMessage<VectorOutput> | undefined): boolean;
}
/**
 * @generated from message qdrant.DenseVector
 */
export declare class DenseVector extends Message<DenseVector> {
    /**
     * @generated from field: repeated float data = 1;
     */
    data: number[];
    constructor(data?: PartialMessage<DenseVector>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DenseVector";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DenseVector;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DenseVector;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DenseVector;
    static equals(a: DenseVector | PlainMessage<DenseVector> | undefined, b: DenseVector | PlainMessage<DenseVector> | undefined): boolean;
}
/**
 * @generated from message qdrant.SparseVector
 */
export declare class SparseVector extends Message<SparseVector> {
    /**
     * @generated from field: repeated float values = 1;
     */
    values: number[];
    /**
     * @generated from field: repeated uint32 indices = 2;
     */
    indices: number[];
    constructor(data?: PartialMessage<SparseVector>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SparseVector";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SparseVector;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SparseVector;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SparseVector;
    static equals(a: SparseVector | PlainMessage<SparseVector> | undefined, b: SparseVector | PlainMessage<SparseVector> | undefined): boolean;
}
/**
 * @generated from message qdrant.MultiDenseVector
 */
export declare class MultiDenseVector extends Message<MultiDenseVector> {
    /**
     * @generated from field: repeated qdrant.DenseVector vectors = 1;
     */
    vectors: DenseVector[];
    constructor(data?: PartialMessage<MultiDenseVector>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.MultiDenseVector";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MultiDenseVector;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MultiDenseVector;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MultiDenseVector;
    static equals(a: MultiDenseVector | PlainMessage<MultiDenseVector> | undefined, b: MultiDenseVector | PlainMessage<MultiDenseVector> | undefined): boolean;
}
/**
 * Vector type to be used in queries. Ids will be substituted with their corresponding vectors from the collection.
 *
 * @generated from message qdrant.VectorInput
 */
export declare class VectorInput extends Message<VectorInput> {
    /**
     * @generated from oneof qdrant.VectorInput.variant
     */
    variant: {
        /**
         * @generated from field: qdrant.PointId id = 1;
         */
        value: PointId;
        case: "id";
    } | {
        /**
         * @generated from field: qdrant.DenseVector dense = 2;
         */
        value: DenseVector;
        case: "dense";
    } | {
        /**
         * @generated from field: qdrant.SparseVector sparse = 3;
         */
        value: SparseVector;
        case: "sparse";
    } | {
        /**
         * @generated from field: qdrant.MultiDenseVector multi_dense = 4;
         */
        value: MultiDenseVector;
        case: "multiDense";
    } | {
        /**
         * @generated from field: qdrant.Document document = 5;
         */
        value: Document;
        case: "document";
    } | {
        /**
         * @generated from field: qdrant.Image image = 6;
         */
        value: Image;
        case: "image";
    } | {
        /**
         * @generated from field: qdrant.InferenceObject object = 7;
         */
        value: InferenceObject;
        case: "object";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<VectorInput>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.VectorInput";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VectorInput;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VectorInput;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VectorInput;
    static equals(a: VectorInput | PlainMessage<VectorInput> | undefined, b: VectorInput | PlainMessage<VectorInput> | undefined): boolean;
}
/**
 * @generated from message qdrant.ShardKeySelector
 */
export declare class ShardKeySelector extends Message<ShardKeySelector> {
    /**
     * List of shard keys which should be used in the request
     *
     * @generated from field: repeated qdrant.ShardKey shard_keys = 1;
     */
    shardKeys: ShardKey[];
    constructor(data?: PartialMessage<ShardKeySelector>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ShardKeySelector";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShardKeySelector;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShardKeySelector;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShardKeySelector;
    static equals(a: ShardKeySelector | PlainMessage<ShardKeySelector> | undefined, b: ShardKeySelector | PlainMessage<ShardKeySelector> | undefined): boolean;
}
/**
 * @generated from message qdrant.UpsertPoints
 */
export declare class UpsertPoints extends Message<UpsertPoints> {
    /**
     * name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Wait until the changes have been applied?
     *
     * @generated from field: optional bool wait = 2;
     */
    wait?: boolean;
    /**
     * @generated from field: repeated qdrant.PointStruct points = 3;
     */
    points: PointStruct[];
    /**
     * Write ordering guarantees
     *
     * @generated from field: optional qdrant.WriteOrdering ordering = 4;
     */
    ordering?: WriteOrdering;
    /**
     * Option for custom sharding to specify used shard keys
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 5;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<UpsertPoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.UpsertPoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertPoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertPoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertPoints;
    static equals(a: UpsertPoints | PlainMessage<UpsertPoints> | undefined, b: UpsertPoints | PlainMessage<UpsertPoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.DeletePoints
 */
export declare class DeletePoints extends Message<DeletePoints> {
    /**
     * name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Wait until the changes have been applied?
     *
     * @generated from field: optional bool wait = 2;
     */
    wait?: boolean;
    /**
     * Affected points
     *
     * @generated from field: qdrant.PointsSelector points = 3;
     */
    points?: PointsSelector;
    /**
     * Write ordering guarantees
     *
     * @generated from field: optional qdrant.WriteOrdering ordering = 4;
     */
    ordering?: WriteOrdering;
    /**
     * Option for custom sharding to specify used shard keys
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 5;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<DeletePoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DeletePoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeletePoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeletePoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeletePoints;
    static equals(a: DeletePoints | PlainMessage<DeletePoints> | undefined, b: DeletePoints | PlainMessage<DeletePoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.GetPoints
 */
export declare class GetPoints extends Message<GetPoints> {
    /**
     * name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * List of points to retrieve
     *
     * @generated from field: repeated qdrant.PointId ids = 2;
     */
    ids: PointId[];
    /**
     * Options for specifying which payload to include or not
     *
     * @generated from field: qdrant.WithPayloadSelector with_payload = 4;
     */
    withPayload?: WithPayloadSelector;
    /**
     * Options for specifying which vectors to include into response
     *
     * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 5;
     */
    withVectors?: WithVectorsSelector;
    /**
     * Options for specifying read consistency guarantees
     *
     * @generated from field: optional qdrant.ReadConsistency read_consistency = 6;
     */
    readConsistency?: ReadConsistency;
    /**
     * Specify in which shards to look for the points, if not specified - look in all shards
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 7;
     */
    shardKeySelector?: ShardKeySelector;
    /**
     * If set, overrides global timeout setting for this request. Unit is seconds.
     *
     * @generated from field: optional uint64 timeout = 8;
     */
    timeout?: bigint;
    constructor(data?: PartialMessage<GetPoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.GetPoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPoints;
    static equals(a: GetPoints | PlainMessage<GetPoints> | undefined, b: GetPoints | PlainMessage<GetPoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.UpdatePointVectors
 */
export declare class UpdatePointVectors extends Message<UpdatePointVectors> {
    /**
     * name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Wait until the changes have been applied?
     *
     * @generated from field: optional bool wait = 2;
     */
    wait?: boolean;
    /**
     * List of points and vectors to update
     *
     * @generated from field: repeated qdrant.PointVectors points = 3;
     */
    points: PointVectors[];
    /**
     * Write ordering guarantees
     *
     * @generated from field: optional qdrant.WriteOrdering ordering = 4;
     */
    ordering?: WriteOrdering;
    /**
     * Option for custom sharding to specify used shard keys
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 5;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<UpdatePointVectors>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.UpdatePointVectors";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdatePointVectors;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdatePointVectors;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdatePointVectors;
    static equals(a: UpdatePointVectors | PlainMessage<UpdatePointVectors> | undefined, b: UpdatePointVectors | PlainMessage<UpdatePointVectors> | undefined): boolean;
}
/**
 * @generated from message qdrant.PointVectors
 */
export declare class PointVectors extends Message<PointVectors> {
    /**
     * ID to update vectors for
     *
     * @generated from field: qdrant.PointId id = 1;
     */
    id?: PointId;
    /**
     * Named vectors to update, leave others intact
     *
     * @generated from field: qdrant.Vectors vectors = 2;
     */
    vectors?: Vectors;
    constructor(data?: PartialMessage<PointVectors>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PointVectors";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointVectors;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointVectors;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointVectors;
    static equals(a: PointVectors | PlainMessage<PointVectors> | undefined, b: PointVectors | PlainMessage<PointVectors> | undefined): boolean;
}
/**
 * @generated from message qdrant.DeletePointVectors
 */
export declare class DeletePointVectors extends Message<DeletePointVectors> {
    /**
     * name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Wait until the changes have been applied?
     *
     * @generated from field: optional bool wait = 2;
     */
    wait?: boolean;
    /**
     * Affected points
     *
     * @generated from field: qdrant.PointsSelector points_selector = 3;
     */
    pointsSelector?: PointsSelector;
    /**
     * List of vector names to delete
     *
     * @generated from field: qdrant.VectorsSelector vectors = 4;
     */
    vectors?: VectorsSelector;
    /**
     * Write ordering guarantees
     *
     * @generated from field: optional qdrant.WriteOrdering ordering = 5;
     */
    ordering?: WriteOrdering;
    /**
     * Option for custom sharding to specify used shard keys
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 6;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<DeletePointVectors>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DeletePointVectors";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeletePointVectors;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeletePointVectors;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeletePointVectors;
    static equals(a: DeletePointVectors | PlainMessage<DeletePointVectors> | undefined, b: DeletePointVectors | PlainMessage<DeletePointVectors> | undefined): boolean;
}
/**
 * @generated from message qdrant.SetPayloadPoints
 */
export declare class SetPayloadPoints extends Message<SetPayloadPoints> {
    /**
     * name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Wait until the changes have been applied?
     *
     * @generated from field: optional bool wait = 2;
     */
    wait?: boolean;
    /**
     * New payload values
     *
     * @generated from field: map<string, qdrant.Value> payload = 3;
     */
    payload: {
        [key: string]: Value;
    };
    /**
     * Affected points
     *
     * @generated from field: optional qdrant.PointsSelector points_selector = 5;
     */
    pointsSelector?: PointsSelector;
    /**
     * Write ordering guarantees
     *
     * @generated from field: optional qdrant.WriteOrdering ordering = 6;
     */
    ordering?: WriteOrdering;
    /**
     * Option for custom sharding to specify used shard keys
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 7;
     */
    shardKeySelector?: ShardKeySelector;
    /**
     * Option for indicate property of payload
     *
     * @generated from field: optional string key = 8;
     */
    key?: string;
    constructor(data?: PartialMessage<SetPayloadPoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SetPayloadPoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetPayloadPoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetPayloadPoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetPayloadPoints;
    static equals(a: SetPayloadPoints | PlainMessage<SetPayloadPoints> | undefined, b: SetPayloadPoints | PlainMessage<SetPayloadPoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.DeletePayloadPoints
 */
export declare class DeletePayloadPoints extends Message<DeletePayloadPoints> {
    /**
     * name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Wait until the changes have been applied?
     *
     * @generated from field: optional bool wait = 2;
     */
    wait?: boolean;
    /**
     * List of keys to delete
     *
     * @generated from field: repeated string keys = 3;
     */
    keys: string[];
    /**
     * Affected points
     *
     * @generated from field: optional qdrant.PointsSelector points_selector = 5;
     */
    pointsSelector?: PointsSelector;
    /**
     * Write ordering guarantees
     *
     * @generated from field: optional qdrant.WriteOrdering ordering = 6;
     */
    ordering?: WriteOrdering;
    /**
     * Option for custom sharding to specify used shard keys
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 7;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<DeletePayloadPoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DeletePayloadPoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeletePayloadPoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeletePayloadPoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeletePayloadPoints;
    static equals(a: DeletePayloadPoints | PlainMessage<DeletePayloadPoints> | undefined, b: DeletePayloadPoints | PlainMessage<DeletePayloadPoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.ClearPayloadPoints
 */
export declare class ClearPayloadPoints extends Message<ClearPayloadPoints> {
    /**
     * name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Wait until the changes have been applied?
     *
     * @generated from field: optional bool wait = 2;
     */
    wait?: boolean;
    /**
     * Affected points
     *
     * @generated from field: qdrant.PointsSelector points = 3;
     */
    points?: PointsSelector;
    /**
     * Write ordering guarantees
     *
     * @generated from field: optional qdrant.WriteOrdering ordering = 4;
     */
    ordering?: WriteOrdering;
    /**
     * Option for custom sharding to specify used shard keys
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 5;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<ClearPayloadPoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ClearPayloadPoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClearPayloadPoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClearPayloadPoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClearPayloadPoints;
    static equals(a: ClearPayloadPoints | PlainMessage<ClearPayloadPoints> | undefined, b: ClearPayloadPoints | PlainMessage<ClearPayloadPoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.CreateFieldIndexCollection
 */
export declare class CreateFieldIndexCollection extends Message<CreateFieldIndexCollection> {
    /**
     * name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Wait until the changes have been applied?
     *
     * @generated from field: optional bool wait = 2;
     */
    wait?: boolean;
    /**
     * Field name to index
     *
     * @generated from field: string field_name = 3;
     */
    fieldName: string;
    /**
     * Field type.
     *
     * @generated from field: optional qdrant.FieldType field_type = 4;
     */
    fieldType?: FieldType;
    /**
     * Payload index params.
     *
     * @generated from field: optional qdrant.PayloadIndexParams field_index_params = 5;
     */
    fieldIndexParams?: PayloadIndexParams;
    /**
     * Write ordering guarantees
     *
     * @generated from field: optional qdrant.WriteOrdering ordering = 6;
     */
    ordering?: WriteOrdering;
    constructor(data?: PartialMessage<CreateFieldIndexCollection>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CreateFieldIndexCollection";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateFieldIndexCollection;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateFieldIndexCollection;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateFieldIndexCollection;
    static equals(a: CreateFieldIndexCollection | PlainMessage<CreateFieldIndexCollection> | undefined, b: CreateFieldIndexCollection | PlainMessage<CreateFieldIndexCollection> | undefined): boolean;
}
/**
 * @generated from message qdrant.DeleteFieldIndexCollection
 */
export declare class DeleteFieldIndexCollection extends Message<DeleteFieldIndexCollection> {
    /**
     * name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Wait until the changes have been applied?
     *
     * @generated from field: optional bool wait = 2;
     */
    wait?: boolean;
    /**
     * Field name to delete
     *
     * @generated from field: string field_name = 3;
     */
    fieldName: string;
    /**
     * Write ordering guarantees
     *
     * @generated from field: optional qdrant.WriteOrdering ordering = 4;
     */
    ordering?: WriteOrdering;
    constructor(data?: PartialMessage<DeleteFieldIndexCollection>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DeleteFieldIndexCollection";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteFieldIndexCollection;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteFieldIndexCollection;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteFieldIndexCollection;
    static equals(a: DeleteFieldIndexCollection | PlainMessage<DeleteFieldIndexCollection> | undefined, b: DeleteFieldIndexCollection | PlainMessage<DeleteFieldIndexCollection> | undefined): boolean;
}
/**
 * @generated from message qdrant.PayloadIncludeSelector
 */
export declare class PayloadIncludeSelector extends Message<PayloadIncludeSelector> {
    /**
     * List of payload keys to include into result
     *
     * @generated from field: repeated string fields = 1;
     */
    fields: string[];
    constructor(data?: PartialMessage<PayloadIncludeSelector>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PayloadIncludeSelector";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PayloadIncludeSelector;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PayloadIncludeSelector;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PayloadIncludeSelector;
    static equals(a: PayloadIncludeSelector | PlainMessage<PayloadIncludeSelector> | undefined, b: PayloadIncludeSelector | PlainMessage<PayloadIncludeSelector> | undefined): boolean;
}
/**
 * @generated from message qdrant.PayloadExcludeSelector
 */
export declare class PayloadExcludeSelector extends Message<PayloadExcludeSelector> {
    /**
     * List of payload keys to exclude from the result
     *
     * @generated from field: repeated string fields = 1;
     */
    fields: string[];
    constructor(data?: PartialMessage<PayloadExcludeSelector>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PayloadExcludeSelector";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PayloadExcludeSelector;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PayloadExcludeSelector;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PayloadExcludeSelector;
    static equals(a: PayloadExcludeSelector | PlainMessage<PayloadExcludeSelector> | undefined, b: PayloadExcludeSelector | PlainMessage<PayloadExcludeSelector> | undefined): boolean;
}
/**
 * @generated from message qdrant.WithPayloadSelector
 */
export declare class WithPayloadSelector extends Message<WithPayloadSelector> {
    /**
     * @generated from oneof qdrant.WithPayloadSelector.selector_options
     */
    selectorOptions: {
        /**
         * If `true` - return all payload, if `false` - none
         *
         * @generated from field: bool enable = 1;
         */
        value: boolean;
        case: "enable";
    } | {
        /**
         * @generated from field: qdrant.PayloadIncludeSelector include = 2;
         */
        value: PayloadIncludeSelector;
        case: "include";
    } | {
        /**
         * @generated from field: qdrant.PayloadExcludeSelector exclude = 3;
         */
        value: PayloadExcludeSelector;
        case: "exclude";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<WithPayloadSelector>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.WithPayloadSelector";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WithPayloadSelector;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WithPayloadSelector;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WithPayloadSelector;
    static equals(a: WithPayloadSelector | PlainMessage<WithPayloadSelector> | undefined, b: WithPayloadSelector | PlainMessage<WithPayloadSelector> | undefined): boolean;
}
/**
 * @generated from message qdrant.NamedVectors
 */
export declare class NamedVectors extends Message<NamedVectors> {
    /**
     * @generated from field: map<string, qdrant.Vector> vectors = 1;
     */
    vectors: {
        [key: string]: Vector;
    };
    constructor(data?: PartialMessage<NamedVectors>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.NamedVectors";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedVectors;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedVectors;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedVectors;
    static equals(a: NamedVectors | PlainMessage<NamedVectors> | undefined, b: NamedVectors | PlainMessage<NamedVectors> | undefined): boolean;
}
/**
 * @generated from message qdrant.NamedVectorsOutput
 */
export declare class NamedVectorsOutput extends Message<NamedVectorsOutput> {
    /**
     * @generated from field: map<string, qdrant.VectorOutput> vectors = 1;
     */
    vectors: {
        [key: string]: VectorOutput;
    };
    constructor(data?: PartialMessage<NamedVectorsOutput>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.NamedVectorsOutput";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedVectorsOutput;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedVectorsOutput;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedVectorsOutput;
    static equals(a: NamedVectorsOutput | PlainMessage<NamedVectorsOutput> | undefined, b: NamedVectorsOutput | PlainMessage<NamedVectorsOutput> | undefined): boolean;
}
/**
 * @generated from message qdrant.Vectors
 */
export declare class Vectors extends Message<Vectors> {
    /**
     * @generated from oneof qdrant.Vectors.vectors_options
     */
    vectorsOptions: {
        /**
         * @generated from field: qdrant.Vector vector = 1;
         */
        value: Vector;
        case: "vector";
    } | {
        /**
         * @generated from field: qdrant.NamedVectors vectors = 2;
         */
        value: NamedVectors;
        case: "vectors";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<Vectors>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.Vectors";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Vectors;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Vectors;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Vectors;
    static equals(a: Vectors | PlainMessage<Vectors> | undefined, b: Vectors | PlainMessage<Vectors> | undefined): boolean;
}
/**
 * @generated from message qdrant.VectorsOutput
 */
export declare class VectorsOutput extends Message<VectorsOutput> {
    /**
     * @generated from oneof qdrant.VectorsOutput.vectors_options
     */
    vectorsOptions: {
        /**
         * @generated from field: qdrant.VectorOutput vector = 1;
         */
        value: VectorOutput;
        case: "vector";
    } | {
        /**
         * @generated from field: qdrant.NamedVectorsOutput vectors = 2;
         */
        value: NamedVectorsOutput;
        case: "vectors";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<VectorsOutput>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.VectorsOutput";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VectorsOutput;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VectorsOutput;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VectorsOutput;
    static equals(a: VectorsOutput | PlainMessage<VectorsOutput> | undefined, b: VectorsOutput | PlainMessage<VectorsOutput> | undefined): boolean;
}
/**
 * @generated from message qdrant.VectorsSelector
 */
export declare class VectorsSelector extends Message<VectorsSelector> {
    /**
     * List of vectors to include into result
     *
     * @generated from field: repeated string names = 1;
     */
    names: string[];
    constructor(data?: PartialMessage<VectorsSelector>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.VectorsSelector";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VectorsSelector;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VectorsSelector;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VectorsSelector;
    static equals(a: VectorsSelector | PlainMessage<VectorsSelector> | undefined, b: VectorsSelector | PlainMessage<VectorsSelector> | undefined): boolean;
}
/**
 * @generated from message qdrant.WithVectorsSelector
 */
export declare class WithVectorsSelector extends Message<WithVectorsSelector> {
    /**
     * @generated from oneof qdrant.WithVectorsSelector.selector_options
     */
    selectorOptions: {
        /**
         * If `true` - return all vectors, if `false` - none
         *
         * @generated from field: bool enable = 1;
         */
        value: boolean;
        case: "enable";
    } | {
        /**
         * List of payload keys to include into result
         *
         * @generated from field: qdrant.VectorsSelector include = 2;
         */
        value: VectorsSelector;
        case: "include";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<WithVectorsSelector>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.WithVectorsSelector";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WithVectorsSelector;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WithVectorsSelector;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WithVectorsSelector;
    static equals(a: WithVectorsSelector | PlainMessage<WithVectorsSelector> | undefined, b: WithVectorsSelector | PlainMessage<WithVectorsSelector> | undefined): boolean;
}
/**
 * @generated from message qdrant.QuantizationSearchParams
 */
export declare class QuantizationSearchParams extends Message<QuantizationSearchParams> {
    /**
     *
     * If set to true, search will ignore quantized vector data
     *
     * @generated from field: optional bool ignore = 1;
     */
    ignore?: boolean;
    /**
     *
     * If true, use original vectors to re-score top-k results. If ignored, qdrant decides automatically does rescore enabled or not.
     *
     * @generated from field: optional bool rescore = 2;
     */
    rescore?: boolean;
    /**
     *
     * Oversampling factor for quantization.
     *
     * Defines how many extra vectors should be pre-selected using quantized index,
     * and then re-scored using original vectors.
     *
     * For example, if `oversampling` is 2.4 and `limit` is 100, then 240 vectors will be pre-selected using quantized index,
     * and then top-100 will be returned after re-scoring.
     *
     * @generated from field: optional double oversampling = 3;
     */
    oversampling?: number;
    constructor(data?: PartialMessage<QuantizationSearchParams>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.QuantizationSearchParams";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuantizationSearchParams;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuantizationSearchParams;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuantizationSearchParams;
    static equals(a: QuantizationSearchParams | PlainMessage<QuantizationSearchParams> | undefined, b: QuantizationSearchParams | PlainMessage<QuantizationSearchParams> | undefined): boolean;
}
/**
 * @generated from message qdrant.SearchParams
 */
export declare class SearchParams extends Message<SearchParams> {
    /**
     *
     * Params relevant to HNSW index. Size of the beam in a beam-search.
     * Larger the value - more accurate the result, more time required for search.
     *
     * @generated from field: optional uint64 hnsw_ef = 1;
     */
    hnswEf?: bigint;
    /**
     *
     * Search without approximation. If set to true, search may run long but with exact results.
     *
     * @generated from field: optional bool exact = 2;
     */
    exact?: boolean;
    /**
     *
     * If set to true, search will ignore quantized vector data
     *
     * @generated from field: optional qdrant.QuantizationSearchParams quantization = 3;
     */
    quantization?: QuantizationSearchParams;
    /**
     *
     * If enabled, the engine will only perform search among indexed or small segments.
     * Using this option prevents slow searches in case of delayed index, but does not
     * guarantee that all uploaded vectors will be included in search results
     *
     * @generated from field: optional bool indexed_only = 4;
     */
    indexedOnly?: boolean;
    constructor(data?: PartialMessage<SearchParams>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SearchParams";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchParams;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchParams;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchParams;
    static equals(a: SearchParams | PlainMessage<SearchParams> | undefined, b: SearchParams | PlainMessage<SearchParams> | undefined): boolean;
}
/**
 * @generated from message qdrant.SearchPoints
 */
export declare class SearchPoints extends Message<SearchPoints> {
    /**
     * name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * vector
     *
     * @generated from field: repeated float vector = 2;
     */
    vector: number[];
    /**
     * Filter conditions - return only those points that satisfy the specified conditions
     *
     * @generated from field: qdrant.Filter filter = 3;
     */
    filter?: Filter;
    /**
     * Max number of result
     *
     * @generated from field: uint64 limit = 4;
     */
    limit: bigint;
    /**
     * Options for specifying which payload to include or not
     *
     * @generated from field: qdrant.WithPayloadSelector with_payload = 6;
     */
    withPayload?: WithPayloadSelector;
    /**
     * Search config
     *
     * @generated from field: qdrant.SearchParams params = 7;
     */
    params?: SearchParams;
    /**
     * If provided - cut off results with worse scores
     *
     * @generated from field: optional float score_threshold = 8;
     */
    scoreThreshold?: number;
    /**
     * Offset of the result
     *
     * @generated from field: optional uint64 offset = 9;
     */
    offset?: bigint;
    /**
     * Which vector to use for search, if not specified - use default vector
     *
     * @generated from field: optional string vector_name = 10;
     */
    vectorName?: string;
    /**
     * Options for specifying which vectors to include into response
     *
     * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 11;
     */
    withVectors?: WithVectorsSelector;
    /**
     * Options for specifying read consistency guarantees
     *
     * @generated from field: optional qdrant.ReadConsistency read_consistency = 12;
     */
    readConsistency?: ReadConsistency;
    /**
     * If set, overrides global timeout setting for this request. Unit is seconds.
     *
     * @generated from field: optional uint64 timeout = 13;
     */
    timeout?: bigint;
    /**
     * Specify in which shards to look for the points, if not specified - look in all shards
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 14;
     */
    shardKeySelector?: ShardKeySelector;
    /**
     * @generated from field: optional qdrant.SparseIndices sparse_indices = 15;
     */
    sparseIndices?: SparseIndices;
    constructor(data?: PartialMessage<SearchPoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SearchPoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchPoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchPoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchPoints;
    static equals(a: SearchPoints | PlainMessage<SearchPoints> | undefined, b: SearchPoints | PlainMessage<SearchPoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.SearchBatchPoints
 */
export declare class SearchBatchPoints extends Message<SearchBatchPoints> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * @generated from field: repeated qdrant.SearchPoints search_points = 2;
     */
    searchPoints: SearchPoints[];
    /**
     * Options for specifying read consistency guarantees
     *
     * @generated from field: optional qdrant.ReadConsistency read_consistency = 3;
     */
    readConsistency?: ReadConsistency;
    /**
     * If set, overrides global timeout setting for this request. Unit is seconds.
     *
     * @generated from field: optional uint64 timeout = 4;
     */
    timeout?: bigint;
    constructor(data?: PartialMessage<SearchBatchPoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SearchBatchPoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchBatchPoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchBatchPoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchBatchPoints;
    static equals(a: SearchBatchPoints | PlainMessage<SearchBatchPoints> | undefined, b: SearchBatchPoints | PlainMessage<SearchBatchPoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.WithLookup
 */
export declare class WithLookup extends Message<WithLookup> {
    /**
     * Name of the collection to use for points lookup
     *
     * @generated from field: string collection = 1;
     */
    collection: string;
    /**
     * Options for specifying which payload to include (or not)
     *
     * @generated from field: optional qdrant.WithPayloadSelector with_payload = 2;
     */
    withPayload?: WithPayloadSelector;
    /**
     * Options for specifying which vectors to include (or not)
     *
     * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 3;
     */
    withVectors?: WithVectorsSelector;
    constructor(data?: PartialMessage<WithLookup>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.WithLookup";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WithLookup;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WithLookup;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WithLookup;
    static equals(a: WithLookup | PlainMessage<WithLookup> | undefined, b: WithLookup | PlainMessage<WithLookup> | undefined): boolean;
}
/**
 * @generated from message qdrant.SearchPointGroups
 */
export declare class SearchPointGroups extends Message<SearchPointGroups> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Vector to compare against
     *
     * @generated from field: repeated float vector = 2;
     */
    vector: number[];
    /**
     * Filter conditions - return only those points that satisfy the specified conditions
     *
     * @generated from field: qdrant.Filter filter = 3;
     */
    filter?: Filter;
    /**
     * Max number of result
     *
     * @generated from field: uint32 limit = 4;
     */
    limit: number;
    /**
     * Options for specifying which payload to include or not
     *
     * @generated from field: qdrant.WithPayloadSelector with_payload = 5;
     */
    withPayload?: WithPayloadSelector;
    /**
     * Search config
     *
     * @generated from field: qdrant.SearchParams params = 6;
     */
    params?: SearchParams;
    /**
     * If provided - cut off results with worse scores
     *
     * @generated from field: optional float score_threshold = 7;
     */
    scoreThreshold?: number;
    /**
     * Which vector to use for search, if not specified - use default vector
     *
     * @generated from field: optional string vector_name = 8;
     */
    vectorName?: string;
    /**
     * Options for specifying which vectors to include into response
     *
     * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 9;
     */
    withVectors?: WithVectorsSelector;
    /**
     * Payload field to group by, must be a string or number field. If there are multiple values for the field, all of them will be used. One point can be in multiple groups.
     *
     * @generated from field: string group_by = 10;
     */
    groupBy: string;
    /**
     * Maximum amount of points to return per group
     *
     * @generated from field: uint32 group_size = 11;
     */
    groupSize: number;
    /**
     * Options for specifying read consistency guarantees
     *
     * @generated from field: optional qdrant.ReadConsistency read_consistency = 12;
     */
    readConsistency?: ReadConsistency;
    /**
     * Options for specifying how to use the group id to lookup points in another collection
     *
     * @generated from field: optional qdrant.WithLookup with_lookup = 13;
     */
    withLookup?: WithLookup;
    /**
     * If set, overrides global timeout setting for this request. Unit is seconds.
     *
     * @generated from field: optional uint64 timeout = 14;
     */
    timeout?: bigint;
    /**
     * Specify in which shards to look for the points, if not specified - look in all shards
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 15;
     */
    shardKeySelector?: ShardKeySelector;
    /**
     * @generated from field: optional qdrant.SparseIndices sparse_indices = 16;
     */
    sparseIndices?: SparseIndices;
    constructor(data?: PartialMessage<SearchPointGroups>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SearchPointGroups";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchPointGroups;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchPointGroups;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchPointGroups;
    static equals(a: SearchPointGroups | PlainMessage<SearchPointGroups> | undefined, b: SearchPointGroups | PlainMessage<SearchPointGroups> | undefined): boolean;
}
/**
 * @generated from message qdrant.StartFrom
 */
export declare class StartFrom extends Message<StartFrom> {
    /**
     * @generated from oneof qdrant.StartFrom.value
     */
    value: {
        /**
         * @generated from field: double float = 1;
         */
        value: number;
        case: "float";
    } | {
        /**
         * @generated from field: int64 integer = 2;
         */
        value: bigint;
        case: "integer";
    } | {
        /**
         * @generated from field: google.protobuf.Timestamp timestamp = 3;
         */
        value: Timestamp;
        case: "timestamp";
    } | {
        /**
         * @generated from field: string datetime = 4;
         */
        value: string;
        case: "datetime";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<StartFrom>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.StartFrom";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartFrom;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartFrom;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartFrom;
    static equals(a: StartFrom | PlainMessage<StartFrom> | undefined, b: StartFrom | PlainMessage<StartFrom> | undefined): boolean;
}
/**
 * @generated from message qdrant.OrderBy
 */
export declare class OrderBy extends Message<OrderBy> {
    /**
     * Payload key to order by
     *
     * @generated from field: string key = 1;
     */
    key: string;
    /**
     * Ascending or descending order
     *
     * @generated from field: optional qdrant.Direction direction = 2;
     */
    direction?: Direction;
    /**
     * Start from this value
     *
     * @generated from field: optional qdrant.StartFrom start_from = 3;
     */
    startFrom?: StartFrom;
    constructor(data?: PartialMessage<OrderBy>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.OrderBy";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrderBy;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrderBy;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrderBy;
    static equals(a: OrderBy | PlainMessage<OrderBy> | undefined, b: OrderBy | PlainMessage<OrderBy> | undefined): boolean;
}
/**
 * @generated from message qdrant.ScrollPoints
 */
export declare class ScrollPoints extends Message<ScrollPoints> {
    /**
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Filter conditions - return only those points that satisfy the specified conditions
     *
     * @generated from field: qdrant.Filter filter = 2;
     */
    filter?: Filter;
    /**
     * Start with this ID
     *
     * @generated from field: optional qdrant.PointId offset = 3;
     */
    offset?: PointId;
    /**
     * Max number of result
     *
     * @generated from field: optional uint32 limit = 4;
     */
    limit?: number;
    /**
     * Options for specifying which payload to include or not
     *
     * @generated from field: qdrant.WithPayloadSelector with_payload = 6;
     */
    withPayload?: WithPayloadSelector;
    /**
     * Options for specifying which vectors to include into response
     *
     * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 7;
     */
    withVectors?: WithVectorsSelector;
    /**
     * Options for specifying read consistency guarantees
     *
     * @generated from field: optional qdrant.ReadConsistency read_consistency = 8;
     */
    readConsistency?: ReadConsistency;
    /**
     * Specify in which shards to look for the points, if not specified - look in all shards
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 9;
     */
    shardKeySelector?: ShardKeySelector;
    /**
     * Order the records by a payload field
     *
     * @generated from field: optional qdrant.OrderBy order_by = 10;
     */
    orderBy?: OrderBy;
    /**
     * If set, overrides global timeout setting for this request. Unit is seconds.
     *
     * @generated from field: optional uint64 timeout = 11;
     */
    timeout?: bigint;
    constructor(data?: PartialMessage<ScrollPoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ScrollPoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScrollPoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScrollPoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScrollPoints;
    static equals(a: ScrollPoints | PlainMessage<ScrollPoints> | undefined, b: ScrollPoints | PlainMessage<ScrollPoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.LookupLocation
 */
export declare class LookupLocation extends Message<LookupLocation> {
    /**
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Which vector to use for search, if not specified - use default vector
     *
     * @generated from field: optional string vector_name = 2;
     */
    vectorName?: string;
    /**
     * Specify in which shards to look for the points, if not specified - look in all shards
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 3;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<LookupLocation>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.LookupLocation";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LookupLocation;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LookupLocation;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LookupLocation;
    static equals(a: LookupLocation | PlainMessage<LookupLocation> | undefined, b: LookupLocation | PlainMessage<LookupLocation> | undefined): boolean;
}
/**
 * @generated from message qdrant.RecommendPoints
 */
export declare class RecommendPoints extends Message<RecommendPoints> {
    /**
     * name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Look for vectors closest to the vectors from these points
     *
     * @generated from field: repeated qdrant.PointId positive = 2;
     */
    positive: PointId[];
    /**
     * Try to avoid vectors like the vector from these points
     *
     * @generated from field: repeated qdrant.PointId negative = 3;
     */
    negative: PointId[];
    /**
     * Filter conditions - return only those points that satisfy the specified conditions
     *
     * @generated from field: qdrant.Filter filter = 4;
     */
    filter?: Filter;
    /**
     * Max number of result
     *
     * @generated from field: uint64 limit = 5;
     */
    limit: bigint;
    /**
     * Options for specifying which payload to include or not
     *
     * @generated from field: qdrant.WithPayloadSelector with_payload = 7;
     */
    withPayload?: WithPayloadSelector;
    /**
     * Search config
     *
     * @generated from field: qdrant.SearchParams params = 8;
     */
    params?: SearchParams;
    /**
     * If provided - cut off results with worse scores
     *
     * @generated from field: optional float score_threshold = 9;
     */
    scoreThreshold?: number;
    /**
     * Offset of the result
     *
     * @generated from field: optional uint64 offset = 10;
     */
    offset?: bigint;
    /**
     * Define which vector to use for recommendation, if not specified - default vector
     *
     * @generated from field: optional string using = 11;
     */
    using?: string;
    /**
     * Options for specifying which vectors to include into response
     *
     * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 12;
     */
    withVectors?: WithVectorsSelector;
    /**
     * Name of the collection to use for points lookup, if not specified - use current collection
     *
     * @generated from field: optional qdrant.LookupLocation lookup_from = 13;
     */
    lookupFrom?: LookupLocation;
    /**
     * Options for specifying read consistency guarantees
     *
     * @generated from field: optional qdrant.ReadConsistency read_consistency = 14;
     */
    readConsistency?: ReadConsistency;
    /**
     * How to use the example vectors to find the results
     *
     * @generated from field: optional qdrant.RecommendStrategy strategy = 16;
     */
    strategy?: RecommendStrategy;
    /**
     * Look for vectors closest to those
     *
     * @generated from field: repeated qdrant.Vector positive_vectors = 17;
     */
    positiveVectors: Vector[];
    /**
     * Try to avoid vectors like this
     *
     * @generated from field: repeated qdrant.Vector negative_vectors = 18;
     */
    negativeVectors: Vector[];
    /**
     * If set, overrides global timeout setting for this request. Unit is seconds.
     *
     * @generated from field: optional uint64 timeout = 19;
     */
    timeout?: bigint;
    /**
     * Specify in which shards to look for the points, if not specified - look in all shards
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 20;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<RecommendPoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.RecommendPoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecommendPoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecommendPoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecommendPoints;
    static equals(a: RecommendPoints | PlainMessage<RecommendPoints> | undefined, b: RecommendPoints | PlainMessage<RecommendPoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.RecommendBatchPoints
 */
export declare class RecommendBatchPoints extends Message<RecommendBatchPoints> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * @generated from field: repeated qdrant.RecommendPoints recommend_points = 2;
     */
    recommendPoints: RecommendPoints[];
    /**
     * Options for specifying read consistency guarantees
     *
     * @generated from field: optional qdrant.ReadConsistency read_consistency = 3;
     */
    readConsistency?: ReadConsistency;
    /**
     * If set, overrides global timeout setting for this request. Unit is seconds.
     *
     * @generated from field: optional uint64 timeout = 4;
     */
    timeout?: bigint;
    constructor(data?: PartialMessage<RecommendBatchPoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.RecommendBatchPoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecommendBatchPoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecommendBatchPoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecommendBatchPoints;
    static equals(a: RecommendBatchPoints | PlainMessage<RecommendBatchPoints> | undefined, b: RecommendBatchPoints | PlainMessage<RecommendBatchPoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.RecommendPointGroups
 */
export declare class RecommendPointGroups extends Message<RecommendPointGroups> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Look for vectors closest to the vectors from these points
     *
     * @generated from field: repeated qdrant.PointId positive = 2;
     */
    positive: PointId[];
    /**
     * Try to avoid vectors like the vector from these points
     *
     * @generated from field: repeated qdrant.PointId negative = 3;
     */
    negative: PointId[];
    /**
     * Filter conditions - return only those points that satisfy the specified conditions
     *
     * @generated from field: qdrant.Filter filter = 4;
     */
    filter?: Filter;
    /**
     * Max number of groups in result
     *
     * @generated from field: uint32 limit = 5;
     */
    limit: number;
    /**
     * Options for specifying which payload to include or not
     *
     * @generated from field: qdrant.WithPayloadSelector with_payload = 6;
     */
    withPayload?: WithPayloadSelector;
    /**
     * Search config
     *
     * @generated from field: qdrant.SearchParams params = 7;
     */
    params?: SearchParams;
    /**
     * If provided - cut off results with worse scores
     *
     * @generated from field: optional float score_threshold = 8;
     */
    scoreThreshold?: number;
    /**
     * Define which vector to use for recommendation, if not specified - default vector
     *
     * @generated from field: optional string using = 9;
     */
    using?: string;
    /**
     * Options for specifying which vectors to include into response
     *
     * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 10;
     */
    withVectors?: WithVectorsSelector;
    /**
     * Name of the collection to use for points lookup, if not specified - use current collection
     *
     * @generated from field: optional qdrant.LookupLocation lookup_from = 11;
     */
    lookupFrom?: LookupLocation;
    /**
     * Payload field to group by, must be a string or number field. If there are multiple values for the field, all of them will be used. One point can be in multiple groups.
     *
     * @generated from field: string group_by = 12;
     */
    groupBy: string;
    /**
     * Maximum amount of points to return per group
     *
     * @generated from field: uint32 group_size = 13;
     */
    groupSize: number;
    /**
     * Options for specifying read consistency guarantees
     *
     * @generated from field: optional qdrant.ReadConsistency read_consistency = 14;
     */
    readConsistency?: ReadConsistency;
    /**
     * Options for specifying how to use the group id to lookup points in another collection
     *
     * @generated from field: optional qdrant.WithLookup with_lookup = 15;
     */
    withLookup?: WithLookup;
    /**
     * How to use the example vectors to find the results
     *
     * @generated from field: optional qdrant.RecommendStrategy strategy = 17;
     */
    strategy?: RecommendStrategy;
    /**
     * Look for vectors closest to those
     *
     * @generated from field: repeated qdrant.Vector positive_vectors = 18;
     */
    positiveVectors: Vector[];
    /**
     * Try to avoid vectors like this
     *
     * @generated from field: repeated qdrant.Vector negative_vectors = 19;
     */
    negativeVectors: Vector[];
    /**
     * If set, overrides global timeout setting for this request. Unit is seconds.
     *
     * @generated from field: optional uint64 timeout = 20;
     */
    timeout?: bigint;
    /**
     * Specify in which shards to look for the points, if not specified - look in all shards
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 21;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<RecommendPointGroups>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.RecommendPointGroups";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecommendPointGroups;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecommendPointGroups;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecommendPointGroups;
    static equals(a: RecommendPointGroups | PlainMessage<RecommendPointGroups> | undefined, b: RecommendPointGroups | PlainMessage<RecommendPointGroups> | undefined): boolean;
}
/**
 * @generated from message qdrant.TargetVector
 */
export declare class TargetVector extends Message<TargetVector> {
    /**
     * @generated from oneof qdrant.TargetVector.target
     */
    target: {
        /**
         * @generated from field: qdrant.VectorExample single = 1;
         */
        value: VectorExample;
        case: "single";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<TargetVector>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.TargetVector";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TargetVector;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TargetVector;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TargetVector;
    static equals(a: TargetVector | PlainMessage<TargetVector> | undefined, b: TargetVector | PlainMessage<TargetVector> | undefined): boolean;
}
/**
 * @generated from message qdrant.VectorExample
 */
export declare class VectorExample extends Message<VectorExample> {
    /**
     * @generated from oneof qdrant.VectorExample.example
     */
    example: {
        /**
         * @generated from field: qdrant.PointId id = 1;
         */
        value: PointId;
        case: "id";
    } | {
        /**
         * @generated from field: qdrant.Vector vector = 2;
         */
        value: Vector;
        case: "vector";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<VectorExample>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.VectorExample";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VectorExample;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VectorExample;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VectorExample;
    static equals(a: VectorExample | PlainMessage<VectorExample> | undefined, b: VectorExample | PlainMessage<VectorExample> | undefined): boolean;
}
/**
 * @generated from message qdrant.ContextExamplePair
 */
export declare class ContextExamplePair extends Message<ContextExamplePair> {
    /**
     * @generated from field: qdrant.VectorExample positive = 1;
     */
    positive?: VectorExample;
    /**
     * @generated from field: qdrant.VectorExample negative = 2;
     */
    negative?: VectorExample;
    constructor(data?: PartialMessage<ContextExamplePair>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ContextExamplePair";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContextExamplePair;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContextExamplePair;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContextExamplePair;
    static equals(a: ContextExamplePair | PlainMessage<ContextExamplePair> | undefined, b: ContextExamplePair | PlainMessage<ContextExamplePair> | undefined): boolean;
}
/**
 * @generated from message qdrant.DiscoverPoints
 */
export declare class DiscoverPoints extends Message<DiscoverPoints> {
    /**
     * name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Use this as the primary search objective
     *
     * @generated from field: qdrant.TargetVector target = 2;
     */
    target?: TargetVector;
    /**
     * Search will be constrained by these pairs of examples
     *
     * @generated from field: repeated qdrant.ContextExamplePair context = 3;
     */
    context: ContextExamplePair[];
    /**
     * Filter conditions - return only those points that satisfy the specified conditions
     *
     * @generated from field: qdrant.Filter filter = 4;
     */
    filter?: Filter;
    /**
     * Max number of result
     *
     * @generated from field: uint64 limit = 5;
     */
    limit: bigint;
    /**
     * Options for specifying which payload to include or not
     *
     * @generated from field: qdrant.WithPayloadSelector with_payload = 6;
     */
    withPayload?: WithPayloadSelector;
    /**
     * Search config
     *
     * @generated from field: qdrant.SearchParams params = 7;
     */
    params?: SearchParams;
    /**
     * Offset of the result
     *
     * @generated from field: optional uint64 offset = 8;
     */
    offset?: bigint;
    /**
     * Define which vector to use for recommendation, if not specified - default vector
     *
     * @generated from field: optional string using = 9;
     */
    using?: string;
    /**
     * Options for specifying which vectors to include into response
     *
     * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 10;
     */
    withVectors?: WithVectorsSelector;
    /**
     * Name of the collection to use for points lookup, if not specified - use current collection
     *
     * @generated from field: optional qdrant.LookupLocation lookup_from = 11;
     */
    lookupFrom?: LookupLocation;
    /**
     * Options for specifying read consistency guarantees
     *
     * @generated from field: optional qdrant.ReadConsistency read_consistency = 12;
     */
    readConsistency?: ReadConsistency;
    /**
     * If set, overrides global timeout setting for this request. Unit is seconds.
     *
     * @generated from field: optional uint64 timeout = 13;
     */
    timeout?: bigint;
    /**
     * Specify in which shards to look for the points, if not specified - look in all shards
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 14;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<DiscoverPoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DiscoverPoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiscoverPoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiscoverPoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiscoverPoints;
    static equals(a: DiscoverPoints | PlainMessage<DiscoverPoints> | undefined, b: DiscoverPoints | PlainMessage<DiscoverPoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.DiscoverBatchPoints
 */
export declare class DiscoverBatchPoints extends Message<DiscoverBatchPoints> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * @generated from field: repeated qdrant.DiscoverPoints discover_points = 2;
     */
    discoverPoints: DiscoverPoints[];
    /**
     * Options for specifying read consistency guarantees
     *
     * @generated from field: optional qdrant.ReadConsistency read_consistency = 3;
     */
    readConsistency?: ReadConsistency;
    /**
     * If set, overrides global timeout setting for this request. Unit is seconds.
     *
     * @generated from field: optional uint64 timeout = 4;
     */
    timeout?: bigint;
    constructor(data?: PartialMessage<DiscoverBatchPoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DiscoverBatchPoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiscoverBatchPoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiscoverBatchPoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiscoverBatchPoints;
    static equals(a: DiscoverBatchPoints | PlainMessage<DiscoverBatchPoints> | undefined, b: DiscoverBatchPoints | PlainMessage<DiscoverBatchPoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.CountPoints
 */
export declare class CountPoints extends Message<CountPoints> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Filter conditions - return only those points that satisfy the specified conditions
     *
     * @generated from field: qdrant.Filter filter = 2;
     */
    filter?: Filter;
    /**
     * If `true` - return exact count, if `false` - return approximate count
     *
     * @generated from field: optional bool exact = 3;
     */
    exact?: boolean;
    /**
     * Options for specifying read consistency guarantees
     *
     * @generated from field: optional qdrant.ReadConsistency read_consistency = 4;
     */
    readConsistency?: ReadConsistency;
    /**
     * Specify in which shards to look for the points, if not specified - look in all shards
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 5;
     */
    shardKeySelector?: ShardKeySelector;
    /**
     * If set, overrides global timeout setting for this request. Unit is seconds.
     *
     * @generated from field: optional uint64 timeout = 6;
     */
    timeout?: bigint;
    constructor(data?: PartialMessage<CountPoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CountPoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountPoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountPoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountPoints;
    static equals(a: CountPoints | PlainMessage<CountPoints> | undefined, b: CountPoints | PlainMessage<CountPoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.RecommendInput
 */
export declare class RecommendInput extends Message<RecommendInput> {
    /**
     * Look for vectors closest to the vectors from these points
     *
     * @generated from field: repeated qdrant.VectorInput positive = 1;
     */
    positive: VectorInput[];
    /**
     * Try to avoid vectors like the vector from these points
     *
     * @generated from field: repeated qdrant.VectorInput negative = 2;
     */
    negative: VectorInput[];
    /**
     * How to use the provided vectors to find the results
     *
     * @generated from field: optional qdrant.RecommendStrategy strategy = 3;
     */
    strategy?: RecommendStrategy;
    constructor(data?: PartialMessage<RecommendInput>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.RecommendInput";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecommendInput;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecommendInput;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecommendInput;
    static equals(a: RecommendInput | PlainMessage<RecommendInput> | undefined, b: RecommendInput | PlainMessage<RecommendInput> | undefined): boolean;
}
/**
 * @generated from message qdrant.ContextInputPair
 */
export declare class ContextInputPair extends Message<ContextInputPair> {
    /**
     * A positive vector
     *
     * @generated from field: qdrant.VectorInput positive = 1;
     */
    positive?: VectorInput;
    /**
     * Repel from this vector
     *
     * @generated from field: qdrant.VectorInput negative = 2;
     */
    negative?: VectorInput;
    constructor(data?: PartialMessage<ContextInputPair>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ContextInputPair";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContextInputPair;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContextInputPair;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContextInputPair;
    static equals(a: ContextInputPair | PlainMessage<ContextInputPair> | undefined, b: ContextInputPair | PlainMessage<ContextInputPair> | undefined): boolean;
}
/**
 * @generated from message qdrant.DiscoverInput
 */
export declare class DiscoverInput extends Message<DiscoverInput> {
    /**
     * Use this as the primary search objective
     *
     * @generated from field: qdrant.VectorInput target = 1;
     */
    target?: VectorInput;
    /**
     * Search space will be constrained by these pairs of vectors
     *
     * @generated from field: qdrant.ContextInput context = 2;
     */
    context?: ContextInput;
    constructor(data?: PartialMessage<DiscoverInput>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DiscoverInput";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiscoverInput;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiscoverInput;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiscoverInput;
    static equals(a: DiscoverInput | PlainMessage<DiscoverInput> | undefined, b: DiscoverInput | PlainMessage<DiscoverInput> | undefined): boolean;
}
/**
 * @generated from message qdrant.ContextInput
 */
export declare class ContextInput extends Message<ContextInput> {
    /**
     * Search space will be constrained by these pairs of vectors
     *
     * @generated from field: repeated qdrant.ContextInputPair pairs = 1;
     */
    pairs: ContextInputPair[];
    constructor(data?: PartialMessage<ContextInput>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ContextInput";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContextInput;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContextInput;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContextInput;
    static equals(a: ContextInput | PlainMessage<ContextInput> | undefined, b: ContextInput | PlainMessage<ContextInput> | undefined): boolean;
}
/**
 * @generated from message qdrant.Formula
 */
export declare class Formula extends Message<Formula> {
    /**
     * @generated from field: qdrant.Expression expression = 1;
     */
    expression?: Expression;
    /**
     * @generated from field: map<string, qdrant.Value> defaults = 2;
     */
    defaults: {
        [key: string]: Value;
    };
    constructor(data?: PartialMessage<Formula>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.Formula";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Formula;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Formula;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Formula;
    static equals(a: Formula | PlainMessage<Formula> | undefined, b: Formula | PlainMessage<Formula> | undefined): boolean;
}
/**
 * @generated from message qdrant.Expression
 */
export declare class Expression extends Message<Expression> {
    /**
     * @generated from oneof qdrant.Expression.variant
     */
    variant: {
        /**
         * @generated from field: float constant = 1;
         */
        value: number;
        case: "constant";
    } | {
        /**
         * Payload key or reference to score.
         *
         * @generated from field: string variable = 2;
         */
        value: string;
        case: "variable";
    } | {
        /**
         * Payload condition. If true, becomes 1.0; otherwise 0.0
         *
         * @generated from field: qdrant.Condition condition = 3;
         */
        value: Condition;
        case: "condition";
    } | {
        /**
         * Geographic distance in meters
         *
         * @generated from field: qdrant.GeoDistance geo_distance = 4;
         */
        value: GeoDistance;
        case: "geoDistance";
    } | {
        /**
         * Date-time constant
         *
         * @generated from field: string datetime = 5;
         */
        value: string;
        case: "datetime";
    } | {
        /**
         * Payload key with date-time values
         *
         * @generated from field: string datetime_key = 6;
         */
        value: string;
        case: "datetimeKey";
    } | {
        /**
         * Multiply
         *
         * @generated from field: qdrant.MultExpression mult = 7;
         */
        value: MultExpression;
        case: "mult";
    } | {
        /**
         * Sum
         *
         * @generated from field: qdrant.SumExpression sum = 8;
         */
        value: SumExpression;
        case: "sum";
    } | {
        /**
         * Divide
         *
         * @generated from field: qdrant.DivExpression div = 9;
         */
        value: DivExpression;
        case: "div";
    } | {
        /**
         * Negate
         *
         * @generated from field: qdrant.Expression neg = 10;
         */
        value: Expression;
        case: "neg";
    } | {
        /**
         * Absolute value
         *
         * @generated from field: qdrant.Expression abs = 11;
         */
        value: Expression;
        case: "abs";
    } | {
        /**
         * Square root
         *
         * @generated from field: qdrant.Expression sqrt = 12;
         */
        value: Expression;
        case: "sqrt";
    } | {
        /**
         * Power
         *
         * @generated from field: qdrant.PowExpression pow = 13;
         */
        value: PowExpression;
        case: "pow";
    } | {
        /**
         * Exponential
         *
         * @generated from field: qdrant.Expression exp = 14;
         */
        value: Expression;
        case: "exp";
    } | {
        /**
         * Logarithm
         *
         * @generated from field: qdrant.Expression log10 = 15;
         */
        value: Expression;
        case: "log10";
    } | {
        /**
         * Natural logarithm
         *
         * @generated from field: qdrant.Expression ln = 16;
         */
        value: Expression;
        case: "ln";
    } | {
        /**
         * Exponential decay
         *
         * @generated from field: qdrant.DecayParamsExpression exp_decay = 17;
         */
        value: DecayParamsExpression;
        case: "expDecay";
    } | {
        /**
         * Gaussian decay
         *
         * @generated from field: qdrant.DecayParamsExpression gauss_decay = 18;
         */
        value: DecayParamsExpression;
        case: "gaussDecay";
    } | {
        /**
         * Linear decay
         *
         * @generated from field: qdrant.DecayParamsExpression lin_decay = 19;
         */
        value: DecayParamsExpression;
        case: "linDecay";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<Expression>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.Expression";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Expression;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Expression;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Expression;
    static equals(a: Expression | PlainMessage<Expression> | undefined, b: Expression | PlainMessage<Expression> | undefined): boolean;
}
/**
 * @generated from message qdrant.GeoDistance
 */
export declare class GeoDistance extends Message<GeoDistance> {
    /**
     * @generated from field: qdrant.GeoPoint origin = 1;
     */
    origin?: GeoPoint;
    /**
     * @generated from field: string to = 2;
     */
    to: string;
    constructor(data?: PartialMessage<GeoDistance>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.GeoDistance";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoDistance;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoDistance;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoDistance;
    static equals(a: GeoDistance | PlainMessage<GeoDistance> | undefined, b: GeoDistance | PlainMessage<GeoDistance> | undefined): boolean;
}
/**
 * @generated from message qdrant.MultExpression
 */
export declare class MultExpression extends Message<MultExpression> {
    /**
     * @generated from field: repeated qdrant.Expression mult = 1;
     */
    mult: Expression[];
    constructor(data?: PartialMessage<MultExpression>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.MultExpression";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MultExpression;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MultExpression;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MultExpression;
    static equals(a: MultExpression | PlainMessage<MultExpression> | undefined, b: MultExpression | PlainMessage<MultExpression> | undefined): boolean;
}
/**
 * @generated from message qdrant.SumExpression
 */
export declare class SumExpression extends Message<SumExpression> {
    /**
     * @generated from field: repeated qdrant.Expression sum = 1;
     */
    sum: Expression[];
    constructor(data?: PartialMessage<SumExpression>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SumExpression";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SumExpression;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SumExpression;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SumExpression;
    static equals(a: SumExpression | PlainMessage<SumExpression> | undefined, b: SumExpression | PlainMessage<SumExpression> | undefined): boolean;
}
/**
 * @generated from message qdrant.DivExpression
 */
export declare class DivExpression extends Message<DivExpression> {
    /**
     * @generated from field: qdrant.Expression left = 1;
     */
    left?: Expression;
    /**
     * @generated from field: qdrant.Expression right = 2;
     */
    right?: Expression;
    /**
     * @generated from field: optional float by_zero_default = 3;
     */
    byZeroDefault?: number;
    constructor(data?: PartialMessage<DivExpression>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DivExpression";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DivExpression;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DivExpression;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DivExpression;
    static equals(a: DivExpression | PlainMessage<DivExpression> | undefined, b: DivExpression | PlainMessage<DivExpression> | undefined): boolean;
}
/**
 * @generated from message qdrant.PowExpression
 */
export declare class PowExpression extends Message<PowExpression> {
    /**
     * @generated from field: qdrant.Expression base = 1;
     */
    base?: Expression;
    /**
     * @generated from field: qdrant.Expression exponent = 2;
     */
    exponent?: Expression;
    constructor(data?: PartialMessage<PowExpression>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PowExpression";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PowExpression;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PowExpression;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PowExpression;
    static equals(a: PowExpression | PlainMessage<PowExpression> | undefined, b: PowExpression | PlainMessage<PowExpression> | undefined): boolean;
}
/**
 * @generated from message qdrant.DecayParamsExpression
 */
export declare class DecayParamsExpression extends Message<DecayParamsExpression> {
    /**
     * The variable to decay
     *
     * @generated from field: qdrant.Expression x = 1;
     */
    x?: Expression;
    /**
     * The target value to start decaying from. Defaults to 0.
     *
     * @generated from field: optional qdrant.Expression target = 2;
     */
    target?: Expression;
    /**
     * The scale factor of the decay, in terms of `x`. Defaults to 1.0. Must be a non-zero positive number.
     *
     * @generated from field: optional float scale = 3;
     */
    scale?: number;
    /**
     * The midpoint of the decay. Defaults to 0.5. Output will be this value when `|x - target| == scale`.
     *
     * @generated from field: optional float midpoint = 4;
     */
    midpoint?: number;
    constructor(data?: PartialMessage<DecayParamsExpression>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DecayParamsExpression";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DecayParamsExpression;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DecayParamsExpression;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DecayParamsExpression;
    static equals(a: DecayParamsExpression | PlainMessage<DecayParamsExpression> | undefined, b: DecayParamsExpression | PlainMessage<DecayParamsExpression> | undefined): boolean;
}
/**
 * @generated from message qdrant.NearestInputWithMmr
 */
export declare class NearestInputWithMmr extends Message<NearestInputWithMmr> {
    /**
     * The vector to search for nearest neighbors.
     *
     * @generated from field: qdrant.VectorInput nearest = 1;
     */
    nearest?: VectorInput;
    /**
     * Perform MMR (Maximal Marginal Relevance) reranking after search,
     * using the same vector in this query to calculate relevance.
     *
     * @generated from field: qdrant.Mmr mmr = 2;
     */
    mmr?: Mmr;
    constructor(data?: PartialMessage<NearestInputWithMmr>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.NearestInputWithMmr";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NearestInputWithMmr;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NearestInputWithMmr;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NearestInputWithMmr;
    static equals(a: NearestInputWithMmr | PlainMessage<NearestInputWithMmr> | undefined, b: NearestInputWithMmr | PlainMessage<NearestInputWithMmr> | undefined): boolean;
}
/**
 * Maximal Marginal Relevance (MMR) algorithm for re-ranking the points.
 *
 * @generated from message qdrant.Mmr
 */
export declare class Mmr extends Message<Mmr> {
    /**
     * Tunable parameter for the MMR algorithm.
     * Determines the balance between diversity and relevance.
     *
     * A higher value favors diversity (dissimilarity to selected results),
     * while a lower value favors relevance (similarity to the query vector).
     *
     * Must be in the range [0, 1].
     * Default value is 0.5.
     *
     * @generated from field: optional float diversity = 2;
     */
    diversity?: number;
    /**
     * The maximum number of candidates to consider for re-ranking.
     *
     * If not specified, the `limit` value is used.
     *
     * @generated from field: optional uint32 candidates_limit = 3;
     */
    candidatesLimit?: number;
    constructor(data?: PartialMessage<Mmr>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.Mmr";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Mmr;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Mmr;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Mmr;
    static equals(a: Mmr | PlainMessage<Mmr> | undefined, b: Mmr | PlainMessage<Mmr> | undefined): boolean;
}
/**
 * @generated from message qdrant.Query
 */
export declare class Query extends Message<Query> {
    /**
     * @generated from oneof qdrant.Query.variant
     */
    variant: {
        /**
         * Find the nearest neighbors to this vector.
         *
         * @generated from field: qdrant.VectorInput nearest = 1;
         */
        value: VectorInput;
        case: "nearest";
    } | {
        /**
         * Use multiple positive and negative vectors to find the results.
         *
         * @generated from field: qdrant.RecommendInput recommend = 2;
         */
        value: RecommendInput;
        case: "recommend";
    } | {
        /**
         * Search for nearest points, but constrain the search space with context
         *
         * @generated from field: qdrant.DiscoverInput discover = 3;
         */
        value: DiscoverInput;
        case: "discover";
    } | {
        /**
         * Return points that live in positive areas.
         *
         * @generated from field: qdrant.ContextInput context = 4;
         */
        value: ContextInput;
        case: "context";
    } | {
        /**
         * Order the points by a payload field.
         *
         * @generated from field: qdrant.OrderBy order_by = 5;
         */
        value: OrderBy;
        case: "orderBy";
    } | {
        /**
         * Fuse the results of multiple prefetches.
         *
         * @generated from field: qdrant.Fusion fusion = 6;
         */
        value: Fusion;
        case: "fusion";
    } | {
        /**
         * Sample points from the collection.
         *
         * @generated from field: qdrant.Sample sample = 7;
         */
        value: Sample;
        case: "sample";
    } | {
        /**
         * Score boosting via an arbitrary formula
         *
         * @generated from field: qdrant.Formula formula = 8;
         */
        value: Formula;
        case: "formula";
    } | {
        /**
         * Search nearest neighbors, but re-rank based on the Maximal Marginal Relevance algorithm.
         *
         * @generated from field: qdrant.NearestInputWithMmr nearest_with_mmr = 9;
         */
        value: NearestInputWithMmr;
        case: "nearestWithMmr";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<Query>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.Query";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Query;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Query;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Query;
    static equals(a: Query | PlainMessage<Query> | undefined, b: Query | PlainMessage<Query> | undefined): boolean;
}
/**
 * @generated from message qdrant.PrefetchQuery
 */
export declare class PrefetchQuery extends Message<PrefetchQuery> {
    /**
     * Sub-requests to perform first. If present, the query will be performed on the results of the prefetches.
     *
     * @generated from field: repeated qdrant.PrefetchQuery prefetch = 1;
     */
    prefetch: PrefetchQuery[];
    /**
     * Query to perform. If missing, returns points ordered by their IDs.
     *
     * @generated from field: optional qdrant.Query query = 2;
     */
    query?: Query;
    /**
     * Define which vector to use for querying. If missing, the default vector is is used.
     *
     * @generated from field: optional string using = 3;
     */
    using?: string;
    /**
     * Filter conditions - return only those points that satisfy the specified conditions.
     *
     * @generated from field: optional qdrant.Filter filter = 4;
     */
    filter?: Filter;
    /**
     * Search params for when there is no prefetch.
     *
     * @generated from field: optional qdrant.SearchParams params = 5;
     */
    params?: SearchParams;
    /**
     * Return points with scores better than this threshold.
     *
     * @generated from field: optional float score_threshold = 6;
     */
    scoreThreshold?: number;
    /**
     * Max number of points. Default is 10
     *
     * @generated from field: optional uint64 limit = 7;
     */
    limit?: bigint;
    /**
     * The location to use for IDs lookup, if not specified - use the current collection and the 'using' vector
     *
     * @generated from field: optional qdrant.LookupLocation lookup_from = 8;
     */
    lookupFrom?: LookupLocation;
    constructor(data?: PartialMessage<PrefetchQuery>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PrefetchQuery";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrefetchQuery;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrefetchQuery;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrefetchQuery;
    static equals(a: PrefetchQuery | PlainMessage<PrefetchQuery> | undefined, b: PrefetchQuery | PlainMessage<PrefetchQuery> | undefined): boolean;
}
/**
 * @generated from message qdrant.QueryPoints
 */
export declare class QueryPoints extends Message<QueryPoints> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Sub-requests to perform first. If present, the query will be performed on the results of the prefetches.
     *
     * @generated from field: repeated qdrant.PrefetchQuery prefetch = 2;
     */
    prefetch: PrefetchQuery[];
    /**
     * Query to perform. If missing, returns points ordered by their IDs.
     *
     * @generated from field: optional qdrant.Query query = 3;
     */
    query?: Query;
    /**
     * Define which vector to use for querying. If missing, the default vector is used.
     *
     * @generated from field: optional string using = 4;
     */
    using?: string;
    /**
     * Filter conditions - return only those points that satisfy the specified conditions.
     *
     * @generated from field: optional qdrant.Filter filter = 5;
     */
    filter?: Filter;
    /**
     * Search params for when there is no prefetch.
     *
     * @generated from field: optional qdrant.SearchParams params = 6;
     */
    params?: SearchParams;
    /**
     * Return points with scores better than this threshold.
     *
     * @generated from field: optional float score_threshold = 7;
     */
    scoreThreshold?: number;
    /**
     * Max number of points. Default is 10.
     *
     * @generated from field: optional uint64 limit = 8;
     */
    limit?: bigint;
    /**
     * Offset of the result. Skip this many points. Default is 0.
     *
     * @generated from field: optional uint64 offset = 9;
     */
    offset?: bigint;
    /**
     * Options for specifying which vectors to include into the response.
     *
     * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 10;
     */
    withVectors?: WithVectorsSelector;
    /**
     * Options for specifying which payload to include or not.
     *
     * @generated from field: optional qdrant.WithPayloadSelector with_payload = 11;
     */
    withPayload?: WithPayloadSelector;
    /**
     * Options for specifying read consistency guarantees.
     *
     * @generated from field: optional qdrant.ReadConsistency read_consistency = 12;
     */
    readConsistency?: ReadConsistency;
    /**
     * Specify in which shards to look for the points, if not specified - look in all shards.
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 13;
     */
    shardKeySelector?: ShardKeySelector;
    /**
     * The location to use for IDs lookup, if not specified - use the current collection and the 'using' vector
     *
     * @generated from field: optional qdrant.LookupLocation lookup_from = 14;
     */
    lookupFrom?: LookupLocation;
    /**
     * If set, overrides global timeout setting for this request. Unit is seconds.
     *
     * @generated from field: optional uint64 timeout = 15;
     */
    timeout?: bigint;
    constructor(data?: PartialMessage<QueryPoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.QueryPoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPoints;
    static equals(a: QueryPoints | PlainMessage<QueryPoints> | undefined, b: QueryPoints | PlainMessage<QueryPoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.QueryBatchPoints
 */
export declare class QueryBatchPoints extends Message<QueryBatchPoints> {
    /**
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * @generated from field: repeated qdrant.QueryPoints query_points = 2;
     */
    queryPoints: QueryPoints[];
    /**
     * Options for specifying read consistency guarantees
     *
     * @generated from field: optional qdrant.ReadConsistency read_consistency = 3;
     */
    readConsistency?: ReadConsistency;
    /**
     * If set, overrides global timeout setting for this request. Unit is seconds.
     *
     * @generated from field: optional uint64 timeout = 4;
     */
    timeout?: bigint;
    constructor(data?: PartialMessage<QueryBatchPoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.QueryBatchPoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBatchPoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBatchPoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBatchPoints;
    static equals(a: QueryBatchPoints | PlainMessage<QueryBatchPoints> | undefined, b: QueryBatchPoints | PlainMessage<QueryBatchPoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.QueryPointGroups
 */
export declare class QueryPointGroups extends Message<QueryPointGroups> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Sub-requests to perform first. If present, the query will be performed on the results of the prefetches.
     *
     * @generated from field: repeated qdrant.PrefetchQuery prefetch = 2;
     */
    prefetch: PrefetchQuery[];
    /**
     * Query to perform. If missing, returns points ordered by their IDs.
     *
     * @generated from field: optional qdrant.Query query = 3;
     */
    query?: Query;
    /**
     * Define which vector to use for querying. If missing, the default vector is used.
     *
     * @generated from field: optional string using = 4;
     */
    using?: string;
    /**
     * Filter conditions - return only those points that satisfy the specified conditions.
     *
     * @generated from field: optional qdrant.Filter filter = 5;
     */
    filter?: Filter;
    /**
     * Search params for when there is no prefetch.
     *
     * @generated from field: optional qdrant.SearchParams params = 6;
     */
    params?: SearchParams;
    /**
     * Return points with scores better than this threshold.
     *
     * @generated from field: optional float score_threshold = 7;
     */
    scoreThreshold?: number;
    /**
     * Options for specifying which payload to include or not
     *
     * @generated from field: qdrant.WithPayloadSelector with_payload = 8;
     */
    withPayload?: WithPayloadSelector;
    /**
     * Options for specifying which vectors to include into response
     *
     * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 9;
     */
    withVectors?: WithVectorsSelector;
    /**
     * The location to use for IDs lookup, if not specified - use the current collection and the 'using' vector
     *
     * @generated from field: optional qdrant.LookupLocation lookup_from = 10;
     */
    lookupFrom?: LookupLocation;
    /**
     * Max number of points. Default is 3.
     *
     * @generated from field: optional uint64 limit = 11;
     */
    limit?: bigint;
    /**
     * Maximum amount of points to return per group. Default to 10.
     *
     * @generated from field: optional uint64 group_size = 12;
     */
    groupSize?: bigint;
    /**
     * Payload field to group by, must be a string or number field. If there are multiple values for the field, all of them will be used. One point can be in multiple groups.
     *
     * @generated from field: string group_by = 13;
     */
    groupBy: string;
    /**
     * Options for specifying read consistency guarantees
     *
     * @generated from field: optional qdrant.ReadConsistency read_consistency = 14;
     */
    readConsistency?: ReadConsistency;
    /**
     * Options for specifying how to use the group id to lookup points in another collection
     *
     * @generated from field: optional qdrant.WithLookup with_lookup = 15;
     */
    withLookup?: WithLookup;
    /**
     * If set, overrides global timeout setting for this request. Unit is seconds.
     *
     * @generated from field: optional uint64 timeout = 16;
     */
    timeout?: bigint;
    /**
     * Specify in which shards to look for the points, if not specified - look in all shards
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 17;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<QueryPointGroups>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.QueryPointGroups";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPointGroups;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPointGroups;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPointGroups;
    static equals(a: QueryPointGroups | PlainMessage<QueryPointGroups> | undefined, b: QueryPointGroups | PlainMessage<QueryPointGroups> | undefined): boolean;
}
/**
 * @generated from message qdrant.FacetCounts
 */
export declare class FacetCounts extends Message<FacetCounts> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Payload key of the facet
     *
     * @generated from field: string key = 2;
     */
    key: string;
    /**
     * Filter conditions - return only those points that satisfy the specified conditions.
     *
     * @generated from field: optional qdrant.Filter filter = 3;
     */
    filter?: Filter;
    /**
     * Max number of facets. Default is 10.
     *
     * @generated from field: optional uint64 limit = 4;
     */
    limit?: bigint;
    /**
     * If true, return exact counts, slower but useful for debugging purposes. Default is false.
     *
     * @generated from field: optional bool exact = 5;
     */
    exact?: boolean;
    /**
     * If set, overrides global timeout setting for this request. Unit is seconds.
     *
     * @generated from field: optional uint64 timeout = 6;
     */
    timeout?: bigint;
    /**
     * Options for specifying read consistency guarantees
     *
     * @generated from field: optional qdrant.ReadConsistency read_consistency = 7;
     */
    readConsistency?: ReadConsistency;
    /**
     * Specify in which shards to look for the points, if not specified - look in all shards
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 8;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<FacetCounts>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.FacetCounts";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FacetCounts;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FacetCounts;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FacetCounts;
    static equals(a: FacetCounts | PlainMessage<FacetCounts> | undefined, b: FacetCounts | PlainMessage<FacetCounts> | undefined): boolean;
}
/**
 * @generated from message qdrant.FacetValue
 */
export declare class FacetValue extends Message<FacetValue> {
    /**
     * @generated from oneof qdrant.FacetValue.variant
     */
    variant: {
        /**
         * String value from the facet
         *
         * @generated from field: string string_value = 1;
         */
        value: string;
        case: "stringValue";
    } | {
        /**
         * Integer value from the facet
         *
         * @generated from field: int64 integer_value = 2;
         */
        value: bigint;
        case: "integerValue";
    } | {
        /**
         * Boolean value from the facet
         *
         * @generated from field: bool bool_value = 3;
         */
        value: boolean;
        case: "boolValue";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<FacetValue>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.FacetValue";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FacetValue;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FacetValue;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FacetValue;
    static equals(a: FacetValue | PlainMessage<FacetValue> | undefined, b: FacetValue | PlainMessage<FacetValue> | undefined): boolean;
}
/**
 * @generated from message qdrant.FacetHit
 */
export declare class FacetHit extends Message<FacetHit> {
    /**
     * Value from the facet
     *
     * @generated from field: qdrant.FacetValue value = 1;
     */
    value?: FacetValue;
    /**
     * Number of points with this value
     *
     * @generated from field: uint64 count = 2;
     */
    count: bigint;
    constructor(data?: PartialMessage<FacetHit>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.FacetHit";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FacetHit;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FacetHit;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FacetHit;
    static equals(a: FacetHit | PlainMessage<FacetHit> | undefined, b: FacetHit | PlainMessage<FacetHit> | undefined): boolean;
}
/**
 * @generated from message qdrant.SearchMatrixPoints
 */
export declare class SearchMatrixPoints extends Message<SearchMatrixPoints> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Filter conditions - return only those points that satisfy the specified conditions.
     *
     * @generated from field: optional qdrant.Filter filter = 2;
     */
    filter?: Filter;
    /**
     * How many points to select and search within. Default is 10.
     *
     * @generated from field: optional uint64 sample = 3;
     */
    sample?: bigint;
    /**
     * How many neighbours per sample to find. Default is 3.
     *
     * @generated from field: optional uint64 limit = 4;
     */
    limit?: bigint;
    /**
     * Define which vector to use for querying. If missing, the default vector is is used.
     *
     * @generated from field: optional string using = 5;
     */
    using?: string;
    /**
     * If set, overrides global timeout setting for this request. Unit is seconds.
     *
     * @generated from field: optional uint64 timeout = 6;
     */
    timeout?: bigint;
    /**
     * Options for specifying read consistency guarantees
     *
     * @generated from field: optional qdrant.ReadConsistency read_consistency = 7;
     */
    readConsistency?: ReadConsistency;
    /**
     * Specify in which shards to look for the points, if not specified - look in all shards
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 8;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<SearchMatrixPoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SearchMatrixPoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchMatrixPoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchMatrixPoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchMatrixPoints;
    static equals(a: SearchMatrixPoints | PlainMessage<SearchMatrixPoints> | undefined, b: SearchMatrixPoints | PlainMessage<SearchMatrixPoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.SearchMatrixPairs
 */
export declare class SearchMatrixPairs extends Message<SearchMatrixPairs> {
    /**
     * List of pairs of points with scores
     *
     * @generated from field: repeated qdrant.SearchMatrixPair pairs = 1;
     */
    pairs: SearchMatrixPair[];
    constructor(data?: PartialMessage<SearchMatrixPairs>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SearchMatrixPairs";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchMatrixPairs;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchMatrixPairs;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchMatrixPairs;
    static equals(a: SearchMatrixPairs | PlainMessage<SearchMatrixPairs> | undefined, b: SearchMatrixPairs | PlainMessage<SearchMatrixPairs> | undefined): boolean;
}
/**
 * @generated from message qdrant.SearchMatrixPair
 */
export declare class SearchMatrixPair extends Message<SearchMatrixPair> {
    /**
     * first id of the pair
     *
     * @generated from field: qdrant.PointId a = 1;
     */
    a?: PointId;
    /**
     * second id of the pair
     *
     * @generated from field: qdrant.PointId b = 2;
     */
    b?: PointId;
    /**
     * score of the pair
     *
     * @generated from field: float score = 3;
     */
    score: number;
    constructor(data?: PartialMessage<SearchMatrixPair>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SearchMatrixPair";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchMatrixPair;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchMatrixPair;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchMatrixPair;
    static equals(a: SearchMatrixPair | PlainMessage<SearchMatrixPair> | undefined, b: SearchMatrixPair | PlainMessage<SearchMatrixPair> | undefined): boolean;
}
/**
 * @generated from message qdrant.SearchMatrixOffsets
 */
export declare class SearchMatrixOffsets extends Message<SearchMatrixOffsets> {
    /**
     * Row indices of the matrix
     *
     * @generated from field: repeated uint64 offsets_row = 1;
     */
    offsetsRow: bigint[];
    /**
     * Column indices of the matrix
     *
     * @generated from field: repeated uint64 offsets_col = 2;
     */
    offsetsCol: bigint[];
    /**
     * Scores associated with matrix coordinates
     *
     * @generated from field: repeated float scores = 3;
     */
    scores: number[];
    /**
     * Ids of the points in order
     *
     * @generated from field: repeated qdrant.PointId ids = 4;
     */
    ids: PointId[];
    constructor(data?: PartialMessage<SearchMatrixOffsets>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SearchMatrixOffsets";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchMatrixOffsets;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchMatrixOffsets;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchMatrixOffsets;
    static equals(a: SearchMatrixOffsets | PlainMessage<SearchMatrixOffsets> | undefined, b: SearchMatrixOffsets | PlainMessage<SearchMatrixOffsets> | undefined): boolean;
}
/**
 * @generated from message qdrant.PointsUpdateOperation
 */
export declare class PointsUpdateOperation extends Message<PointsUpdateOperation> {
    /**
     * @generated from oneof qdrant.PointsUpdateOperation.operation
     */
    operation: {
        /**
         * @generated from field: qdrant.PointsUpdateOperation.PointStructList upsert = 1;
         */
        value: PointsUpdateOperation_PointStructList;
        case: "upsert";
    } | {
        /**
         * @generated from field: qdrant.PointsSelector delete_deprecated = 2 [deprecated = true];
         * @deprecated
         */
        value: PointsSelector;
        case: "deleteDeprecated";
    } | {
        /**
         * @generated from field: qdrant.PointsUpdateOperation.SetPayload set_payload = 3;
         */
        value: PointsUpdateOperation_SetPayload;
        case: "setPayload";
    } | {
        /**
         * @generated from field: qdrant.PointsUpdateOperation.OverwritePayload overwrite_payload = 4;
         */
        value: PointsUpdateOperation_OverwritePayload;
        case: "overwritePayload";
    } | {
        /**
         * @generated from field: qdrant.PointsUpdateOperation.DeletePayload delete_payload = 5;
         */
        value: PointsUpdateOperation_DeletePayload;
        case: "deletePayload";
    } | {
        /**
         * @generated from field: qdrant.PointsSelector clear_payload_deprecated = 6 [deprecated = true];
         * @deprecated
         */
        value: PointsSelector;
        case: "clearPayloadDeprecated";
    } | {
        /**
         * @generated from field: qdrant.PointsUpdateOperation.UpdateVectors update_vectors = 7;
         */
        value: PointsUpdateOperation_UpdateVectors;
        case: "updateVectors";
    } | {
        /**
         * @generated from field: qdrant.PointsUpdateOperation.DeleteVectors delete_vectors = 8;
         */
        value: PointsUpdateOperation_DeleteVectors;
        case: "deleteVectors";
    } | {
        /**
         * @generated from field: qdrant.PointsUpdateOperation.DeletePoints delete_points = 9;
         */
        value: PointsUpdateOperation_DeletePoints;
        case: "deletePoints";
    } | {
        /**
         * @generated from field: qdrant.PointsUpdateOperation.ClearPayload clear_payload = 10;
         */
        value: PointsUpdateOperation_ClearPayload;
        case: "clearPayload";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<PointsUpdateOperation>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PointsUpdateOperation";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointsUpdateOperation;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointsUpdateOperation;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointsUpdateOperation;
    static equals(a: PointsUpdateOperation | PlainMessage<PointsUpdateOperation> | undefined, b: PointsUpdateOperation | PlainMessage<PointsUpdateOperation> | undefined): boolean;
}
/**
 * @generated from message qdrant.PointsUpdateOperation.PointStructList
 */
export declare class PointsUpdateOperation_PointStructList extends Message<PointsUpdateOperation_PointStructList> {
    /**
     * @generated from field: repeated qdrant.PointStruct points = 1;
     */
    points: PointStruct[];
    /**
     * Option for custom sharding to specify used shard keys
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 2;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<PointsUpdateOperation_PointStructList>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PointsUpdateOperation.PointStructList";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointsUpdateOperation_PointStructList;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointsUpdateOperation_PointStructList;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointsUpdateOperation_PointStructList;
    static equals(a: PointsUpdateOperation_PointStructList | PlainMessage<PointsUpdateOperation_PointStructList> | undefined, b: PointsUpdateOperation_PointStructList | PlainMessage<PointsUpdateOperation_PointStructList> | undefined): boolean;
}
/**
 * @generated from message qdrant.PointsUpdateOperation.SetPayload
 */
export declare class PointsUpdateOperation_SetPayload extends Message<PointsUpdateOperation_SetPayload> {
    /**
     * @generated from field: map<string, qdrant.Value> payload = 1;
     */
    payload: {
        [key: string]: Value;
    };
    /**
     * Affected points
     *
     * @generated from field: optional qdrant.PointsSelector points_selector = 2;
     */
    pointsSelector?: PointsSelector;
    /**
     * Option for custom sharding to specify used shard keys
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 3;
     */
    shardKeySelector?: ShardKeySelector;
    /**
     * Option for indicate property of payload
     *
     * @generated from field: optional string key = 4;
     */
    key?: string;
    constructor(data?: PartialMessage<PointsUpdateOperation_SetPayload>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PointsUpdateOperation.SetPayload";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointsUpdateOperation_SetPayload;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointsUpdateOperation_SetPayload;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointsUpdateOperation_SetPayload;
    static equals(a: PointsUpdateOperation_SetPayload | PlainMessage<PointsUpdateOperation_SetPayload> | undefined, b: PointsUpdateOperation_SetPayload | PlainMessage<PointsUpdateOperation_SetPayload> | undefined): boolean;
}
/**
 * @generated from message qdrant.PointsUpdateOperation.OverwritePayload
 */
export declare class PointsUpdateOperation_OverwritePayload extends Message<PointsUpdateOperation_OverwritePayload> {
    /**
     * @generated from field: map<string, qdrant.Value> payload = 1;
     */
    payload: {
        [key: string]: Value;
    };
    /**
     * Affected points
     *
     * @generated from field: optional qdrant.PointsSelector points_selector = 2;
     */
    pointsSelector?: PointsSelector;
    /**
     * Option for custom sharding to specify used shard keys
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 3;
     */
    shardKeySelector?: ShardKeySelector;
    /**
     * Option for indicate property of payload
     *
     * @generated from field: optional string key = 4;
     */
    key?: string;
    constructor(data?: PartialMessage<PointsUpdateOperation_OverwritePayload>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PointsUpdateOperation.OverwritePayload";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointsUpdateOperation_OverwritePayload;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointsUpdateOperation_OverwritePayload;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointsUpdateOperation_OverwritePayload;
    static equals(a: PointsUpdateOperation_OverwritePayload | PlainMessage<PointsUpdateOperation_OverwritePayload> | undefined, b: PointsUpdateOperation_OverwritePayload | PlainMessage<PointsUpdateOperation_OverwritePayload> | undefined): boolean;
}
/**
 * @generated from message qdrant.PointsUpdateOperation.DeletePayload
 */
export declare class PointsUpdateOperation_DeletePayload extends Message<PointsUpdateOperation_DeletePayload> {
    /**
     * @generated from field: repeated string keys = 1;
     */
    keys: string[];
    /**
     * Affected points
     *
     * @generated from field: optional qdrant.PointsSelector points_selector = 2;
     */
    pointsSelector?: PointsSelector;
    /**
     * Option for custom sharding to specify used shard keys
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 3;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<PointsUpdateOperation_DeletePayload>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PointsUpdateOperation.DeletePayload";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointsUpdateOperation_DeletePayload;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointsUpdateOperation_DeletePayload;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointsUpdateOperation_DeletePayload;
    static equals(a: PointsUpdateOperation_DeletePayload | PlainMessage<PointsUpdateOperation_DeletePayload> | undefined, b: PointsUpdateOperation_DeletePayload | PlainMessage<PointsUpdateOperation_DeletePayload> | undefined): boolean;
}
/**
 * @generated from message qdrant.PointsUpdateOperation.UpdateVectors
 */
export declare class PointsUpdateOperation_UpdateVectors extends Message<PointsUpdateOperation_UpdateVectors> {
    /**
     * List of points and vectors to update
     *
     * @generated from field: repeated qdrant.PointVectors points = 1;
     */
    points: PointVectors[];
    /**
     * Option for custom sharding to specify used shard keys
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 2;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<PointsUpdateOperation_UpdateVectors>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PointsUpdateOperation.UpdateVectors";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointsUpdateOperation_UpdateVectors;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointsUpdateOperation_UpdateVectors;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointsUpdateOperation_UpdateVectors;
    static equals(a: PointsUpdateOperation_UpdateVectors | PlainMessage<PointsUpdateOperation_UpdateVectors> | undefined, b: PointsUpdateOperation_UpdateVectors | PlainMessage<PointsUpdateOperation_UpdateVectors> | undefined): boolean;
}
/**
 * @generated from message qdrant.PointsUpdateOperation.DeleteVectors
 */
export declare class PointsUpdateOperation_DeleteVectors extends Message<PointsUpdateOperation_DeleteVectors> {
    /**
     * Affected points
     *
     * @generated from field: qdrant.PointsSelector points_selector = 1;
     */
    pointsSelector?: PointsSelector;
    /**
     * List of vector names to delete
     *
     * @generated from field: qdrant.VectorsSelector vectors = 2;
     */
    vectors?: VectorsSelector;
    /**
     * Option for custom sharding to specify used shard keys
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 3;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<PointsUpdateOperation_DeleteVectors>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PointsUpdateOperation.DeleteVectors";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointsUpdateOperation_DeleteVectors;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointsUpdateOperation_DeleteVectors;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointsUpdateOperation_DeleteVectors;
    static equals(a: PointsUpdateOperation_DeleteVectors | PlainMessage<PointsUpdateOperation_DeleteVectors> | undefined, b: PointsUpdateOperation_DeleteVectors | PlainMessage<PointsUpdateOperation_DeleteVectors> | undefined): boolean;
}
/**
 * @generated from message qdrant.PointsUpdateOperation.DeletePoints
 */
export declare class PointsUpdateOperation_DeletePoints extends Message<PointsUpdateOperation_DeletePoints> {
    /**
     * Affected points
     *
     * @generated from field: qdrant.PointsSelector points = 1;
     */
    points?: PointsSelector;
    /**
     * Option for custom sharding to specify used shard keys
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 2;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<PointsUpdateOperation_DeletePoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PointsUpdateOperation.DeletePoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointsUpdateOperation_DeletePoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointsUpdateOperation_DeletePoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointsUpdateOperation_DeletePoints;
    static equals(a: PointsUpdateOperation_DeletePoints | PlainMessage<PointsUpdateOperation_DeletePoints> | undefined, b: PointsUpdateOperation_DeletePoints | PlainMessage<PointsUpdateOperation_DeletePoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.PointsUpdateOperation.ClearPayload
 */
export declare class PointsUpdateOperation_ClearPayload extends Message<PointsUpdateOperation_ClearPayload> {
    /**
     * Affected points
     *
     * @generated from field: qdrant.PointsSelector points = 1;
     */
    points?: PointsSelector;
    /**
     * Option for custom sharding to specify used shard keys
     *
     * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 2;
     */
    shardKeySelector?: ShardKeySelector;
    constructor(data?: PartialMessage<PointsUpdateOperation_ClearPayload>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PointsUpdateOperation.ClearPayload";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointsUpdateOperation_ClearPayload;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointsUpdateOperation_ClearPayload;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointsUpdateOperation_ClearPayload;
    static equals(a: PointsUpdateOperation_ClearPayload | PlainMessage<PointsUpdateOperation_ClearPayload> | undefined, b: PointsUpdateOperation_ClearPayload | PlainMessage<PointsUpdateOperation_ClearPayload> | undefined): boolean;
}
/**
 * @generated from message qdrant.UpdateBatchPoints
 */
export declare class UpdateBatchPoints extends Message<UpdateBatchPoints> {
    /**
     * name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Wait until the changes have been applied?
     *
     * @generated from field: optional bool wait = 2;
     */
    wait?: boolean;
    /**
     * @generated from field: repeated qdrant.PointsUpdateOperation operations = 3;
     */
    operations: PointsUpdateOperation[];
    /**
     * Write ordering guarantees
     *
     * @generated from field: optional qdrant.WriteOrdering ordering = 4;
     */
    ordering?: WriteOrdering;
    constructor(data?: PartialMessage<UpdateBatchPoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.UpdateBatchPoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateBatchPoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateBatchPoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateBatchPoints;
    static equals(a: UpdateBatchPoints | PlainMessage<UpdateBatchPoints> | undefined, b: UpdateBatchPoints | PlainMessage<UpdateBatchPoints> | undefined): boolean;
}
/**
 * @generated from message qdrant.PointsOperationResponse
 */
export declare class PointsOperationResponse extends Message<PointsOperationResponse> {
    /**
     * @generated from field: qdrant.UpdateResult result = 1;
     */
    result?: UpdateResult;
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    /**
     * @generated from field: optional qdrant.Usage usage = 3;
     */
    usage?: Usage;
    constructor(data?: PartialMessage<PointsOperationResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PointsOperationResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointsOperationResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointsOperationResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointsOperationResponse;
    static equals(a: PointsOperationResponse | PlainMessage<PointsOperationResponse> | undefined, b: PointsOperationResponse | PlainMessage<PointsOperationResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.UpdateResult
 */
export declare class UpdateResult extends Message<UpdateResult> {
    /**
     * Number of operation
     *
     * @generated from field: optional uint64 operation_id = 1;
     */
    operationId?: bigint;
    /**
     * Operation status
     *
     * @generated from field: qdrant.UpdateStatus status = 2;
     */
    status: UpdateStatus;
    constructor(data?: PartialMessage<UpdateResult>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.UpdateResult";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateResult;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateResult;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateResult;
    static equals(a: UpdateResult | PlainMessage<UpdateResult> | undefined, b: UpdateResult | PlainMessage<UpdateResult> | undefined): boolean;
}
/**
 * @generated from message qdrant.OrderValue
 */
export declare class OrderValue extends Message<OrderValue> {
    /**
     * @generated from oneof qdrant.OrderValue.variant
     */
    variant: {
        /**
         * @generated from field: int64 int = 1;
         */
        value: bigint;
        case: "int";
    } | {
        /**
         * @generated from field: double float = 2;
         */
        value: number;
        case: "float";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<OrderValue>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.OrderValue";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrderValue;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrderValue;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrderValue;
    static equals(a: OrderValue | PlainMessage<OrderValue> | undefined, b: OrderValue | PlainMessage<OrderValue> | undefined): boolean;
}
/**
 * @generated from message qdrant.ScoredPoint
 */
export declare class ScoredPoint extends Message<ScoredPoint> {
    /**
     * Point id
     *
     * @generated from field: qdrant.PointId id = 1;
     */
    id?: PointId;
    /**
     * Payload
     *
     * @generated from field: map<string, qdrant.Value> payload = 2;
     */
    payload: {
        [key: string]: Value;
    };
    /**
     * Similarity score
     *
     * @generated from field: float score = 3;
     */
    score: number;
    /**
     * Last update operation applied to this point
     *
     * @generated from field: uint64 version = 5;
     */
    version: bigint;
    /**
     * Vectors to search
     *
     * @generated from field: optional qdrant.VectorsOutput vectors = 6;
     */
    vectors?: VectorsOutput;
    /**
     * Shard key
     *
     * @generated from field: optional qdrant.ShardKey shard_key = 7;
     */
    shardKey?: ShardKey;
    /**
     * Order by value
     *
     * @generated from field: optional qdrant.OrderValue order_value = 8;
     */
    orderValue?: OrderValue;
    constructor(data?: PartialMessage<ScoredPoint>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ScoredPoint";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScoredPoint;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScoredPoint;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScoredPoint;
    static equals(a: ScoredPoint | PlainMessage<ScoredPoint> | undefined, b: ScoredPoint | PlainMessage<ScoredPoint> | undefined): boolean;
}
/**
 * @generated from message qdrant.GroupId
 */
export declare class GroupId extends Message<GroupId> {
    /**
     * @generated from oneof qdrant.GroupId.kind
     */
    kind: {
        /**
         * Represents a double value.
         *
         * @generated from field: uint64 unsigned_value = 1;
         */
        value: bigint;
        case: "unsignedValue";
    } | {
        /**
         * Represents an integer value
         *
         * @generated from field: int64 integer_value = 2;
         */
        value: bigint;
        case: "integerValue";
    } | {
        /**
         * Represents a string value.
         *
         * @generated from field: string string_value = 3;
         */
        value: string;
        case: "stringValue";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<GroupId>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.GroupId";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GroupId;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GroupId;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GroupId;
    static equals(a: GroupId | PlainMessage<GroupId> | undefined, b: GroupId | PlainMessage<GroupId> | undefined): boolean;
}
/**
 * @generated from message qdrant.PointGroup
 */
export declare class PointGroup extends Message<PointGroup> {
    /**
     * Group id
     *
     * @generated from field: qdrant.GroupId id = 1;
     */
    id?: GroupId;
    /**
     * Points in the group
     *
     * @generated from field: repeated qdrant.ScoredPoint hits = 2;
     */
    hits: ScoredPoint[];
    /**
     * Point(s) from the lookup collection that matches the group id
     *
     * @generated from field: qdrant.RetrievedPoint lookup = 3;
     */
    lookup?: RetrievedPoint;
    constructor(data?: PartialMessage<PointGroup>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PointGroup";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointGroup;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointGroup;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointGroup;
    static equals(a: PointGroup | PlainMessage<PointGroup> | undefined, b: PointGroup | PlainMessage<PointGroup> | undefined): boolean;
}
/**
 * @generated from message qdrant.GroupsResult
 */
export declare class GroupsResult extends Message<GroupsResult> {
    /**
     * Groups
     *
     * @generated from field: repeated qdrant.PointGroup groups = 1;
     */
    groups: PointGroup[];
    constructor(data?: PartialMessage<GroupsResult>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.GroupsResult";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GroupsResult;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GroupsResult;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GroupsResult;
    static equals(a: GroupsResult | PlainMessage<GroupsResult> | undefined, b: GroupsResult | PlainMessage<GroupsResult> | undefined): boolean;
}
/**
 * @generated from message qdrant.SearchResponse
 */
export declare class SearchResponse extends Message<SearchResponse> {
    /**
     * @generated from field: repeated qdrant.ScoredPoint result = 1;
     */
    result: ScoredPoint[];
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    /**
     * @generated from field: optional qdrant.Usage usage = 3;
     */
    usage?: Usage;
    constructor(data?: PartialMessage<SearchResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SearchResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchResponse;
    static equals(a: SearchResponse | PlainMessage<SearchResponse> | undefined, b: SearchResponse | PlainMessage<SearchResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.QueryResponse
 */
export declare class QueryResponse extends Message<QueryResponse> {
    /**
     * @generated from field: repeated qdrant.ScoredPoint result = 1;
     */
    result: ScoredPoint[];
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    /**
     * @generated from field: optional qdrant.Usage usage = 3;
     */
    usage?: Usage;
    constructor(data?: PartialMessage<QueryResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.QueryResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryResponse;
    static equals(a: QueryResponse | PlainMessage<QueryResponse> | undefined, b: QueryResponse | PlainMessage<QueryResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.QueryBatchResponse
 */
export declare class QueryBatchResponse extends Message<QueryBatchResponse> {
    /**
     * @generated from field: repeated qdrant.BatchResult result = 1;
     */
    result: BatchResult[];
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    /**
     * @generated from field: optional qdrant.Usage usage = 3;
     */
    usage?: Usage;
    constructor(data?: PartialMessage<QueryBatchResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.QueryBatchResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBatchResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBatchResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBatchResponse;
    static equals(a: QueryBatchResponse | PlainMessage<QueryBatchResponse> | undefined, b: QueryBatchResponse | PlainMessage<QueryBatchResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.QueryGroupsResponse
 */
export declare class QueryGroupsResponse extends Message<QueryGroupsResponse> {
    /**
     * @generated from field: qdrant.GroupsResult result = 1;
     */
    result?: GroupsResult;
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    /**
     * @generated from field: optional qdrant.Usage usage = 3;
     */
    usage?: Usage;
    constructor(data?: PartialMessage<QueryGroupsResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.QueryGroupsResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryGroupsResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryGroupsResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryGroupsResponse;
    static equals(a: QueryGroupsResponse | PlainMessage<QueryGroupsResponse> | undefined, b: QueryGroupsResponse | PlainMessage<QueryGroupsResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.BatchResult
 */
export declare class BatchResult extends Message<BatchResult> {
    /**
     * @generated from field: repeated qdrant.ScoredPoint result = 1;
     */
    result: ScoredPoint[];
    constructor(data?: PartialMessage<BatchResult>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.BatchResult";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchResult;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchResult;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchResult;
    static equals(a: BatchResult | PlainMessage<BatchResult> | undefined, b: BatchResult | PlainMessage<BatchResult> | undefined): boolean;
}
/**
 * @generated from message qdrant.SearchBatchResponse
 */
export declare class SearchBatchResponse extends Message<SearchBatchResponse> {
    /**
     * @generated from field: repeated qdrant.BatchResult result = 1;
     */
    result: BatchResult[];
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    /**
     * @generated from field: optional qdrant.Usage usage = 3;
     */
    usage?: Usage;
    constructor(data?: PartialMessage<SearchBatchResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SearchBatchResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchBatchResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchBatchResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchBatchResponse;
    static equals(a: SearchBatchResponse | PlainMessage<SearchBatchResponse> | undefined, b: SearchBatchResponse | PlainMessage<SearchBatchResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.SearchGroupsResponse
 */
export declare class SearchGroupsResponse extends Message<SearchGroupsResponse> {
    /**
     * @generated from field: qdrant.GroupsResult result = 1;
     */
    result?: GroupsResult;
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    /**
     * @generated from field: optional qdrant.Usage usage = 3;
     */
    usage?: Usage;
    constructor(data?: PartialMessage<SearchGroupsResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SearchGroupsResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchGroupsResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchGroupsResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchGroupsResponse;
    static equals(a: SearchGroupsResponse | PlainMessage<SearchGroupsResponse> | undefined, b: SearchGroupsResponse | PlainMessage<SearchGroupsResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.CountResponse
 */
export declare class CountResponse extends Message<CountResponse> {
    /**
     * @generated from field: qdrant.CountResult result = 1;
     */
    result?: CountResult;
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    /**
     * @generated from field: optional qdrant.Usage usage = 3;
     */
    usage?: Usage;
    constructor(data?: PartialMessage<CountResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CountResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountResponse;
    static equals(a: CountResponse | PlainMessage<CountResponse> | undefined, b: CountResponse | PlainMessage<CountResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.ScrollResponse
 */
export declare class ScrollResponse extends Message<ScrollResponse> {
    /**
     * Use this offset for the next query
     *
     * @generated from field: optional qdrant.PointId next_page_offset = 1;
     */
    nextPageOffset?: PointId;
    /**
     * @generated from field: repeated qdrant.RetrievedPoint result = 2;
     */
    result: RetrievedPoint[];
    /**
     * Time spent to process
     *
     * @generated from field: double time = 3;
     */
    time: number;
    /**
     * @generated from field: optional qdrant.Usage usage = 4;
     */
    usage?: Usage;
    constructor(data?: PartialMessage<ScrollResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ScrollResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScrollResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScrollResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScrollResponse;
    static equals(a: ScrollResponse | PlainMessage<ScrollResponse> | undefined, b: ScrollResponse | PlainMessage<ScrollResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.CountResult
 */
export declare class CountResult extends Message<CountResult> {
    /**
     * @generated from field: uint64 count = 1;
     */
    count: bigint;
    constructor(data?: PartialMessage<CountResult>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CountResult";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountResult;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountResult;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountResult;
    static equals(a: CountResult | PlainMessage<CountResult> | undefined, b: CountResult | PlainMessage<CountResult> | undefined): boolean;
}
/**
 * @generated from message qdrant.RetrievedPoint
 */
export declare class RetrievedPoint extends Message<RetrievedPoint> {
    /**
     * @generated from field: qdrant.PointId id = 1;
     */
    id?: PointId;
    /**
     * @generated from field: map<string, qdrant.Value> payload = 2;
     */
    payload: {
        [key: string]: Value;
    };
    /**
     * @generated from field: optional qdrant.VectorsOutput vectors = 4;
     */
    vectors?: VectorsOutput;
    /**
     * Shard key
     *
     * @generated from field: optional qdrant.ShardKey shard_key = 5;
     */
    shardKey?: ShardKey;
    /**
     * Order-by value
     *
     * @generated from field: optional qdrant.OrderValue order_value = 6;
     */
    orderValue?: OrderValue;
    constructor(data?: PartialMessage<RetrievedPoint>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.RetrievedPoint";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RetrievedPoint;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RetrievedPoint;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RetrievedPoint;
    static equals(a: RetrievedPoint | PlainMessage<RetrievedPoint> | undefined, b: RetrievedPoint | PlainMessage<RetrievedPoint> | undefined): boolean;
}
/**
 * @generated from message qdrant.GetResponse
 */
export declare class GetResponse extends Message<GetResponse> {
    /**
     * @generated from field: repeated qdrant.RetrievedPoint result = 1;
     */
    result: RetrievedPoint[];
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    /**
     * @generated from field: optional qdrant.Usage usage = 3;
     */
    usage?: Usage;
    constructor(data?: PartialMessage<GetResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.GetResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetResponse;
    static equals(a: GetResponse | PlainMessage<GetResponse> | undefined, b: GetResponse | PlainMessage<GetResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.RecommendResponse
 */
export declare class RecommendResponse extends Message<RecommendResponse> {
    /**
     * @generated from field: repeated qdrant.ScoredPoint result = 1;
     */
    result: ScoredPoint[];
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    /**
     * @generated from field: optional qdrant.Usage usage = 3;
     */
    usage?: Usage;
    constructor(data?: PartialMessage<RecommendResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.RecommendResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecommendResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecommendResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecommendResponse;
    static equals(a: RecommendResponse | PlainMessage<RecommendResponse> | undefined, b: RecommendResponse | PlainMessage<RecommendResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.RecommendBatchResponse
 */
export declare class RecommendBatchResponse extends Message<RecommendBatchResponse> {
    /**
     * @generated from field: repeated qdrant.BatchResult result = 1;
     */
    result: BatchResult[];
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    /**
     * @generated from field: optional qdrant.Usage usage = 3;
     */
    usage?: Usage;
    constructor(data?: PartialMessage<RecommendBatchResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.RecommendBatchResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecommendBatchResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecommendBatchResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecommendBatchResponse;
    static equals(a: RecommendBatchResponse | PlainMessage<RecommendBatchResponse> | undefined, b: RecommendBatchResponse | PlainMessage<RecommendBatchResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.DiscoverResponse
 */
export declare class DiscoverResponse extends Message<DiscoverResponse> {
    /**
     * @generated from field: repeated qdrant.ScoredPoint result = 1;
     */
    result: ScoredPoint[];
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    /**
     * @generated from field: optional qdrant.Usage usage = 3;
     */
    usage?: Usage;
    constructor(data?: PartialMessage<DiscoverResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DiscoverResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiscoverResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiscoverResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiscoverResponse;
    static equals(a: DiscoverResponse | PlainMessage<DiscoverResponse> | undefined, b: DiscoverResponse | PlainMessage<DiscoverResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.DiscoverBatchResponse
 */
export declare class DiscoverBatchResponse extends Message<DiscoverBatchResponse> {
    /**
     * @generated from field: repeated qdrant.BatchResult result = 1;
     */
    result: BatchResult[];
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    /**
     * @generated from field: optional qdrant.Usage usage = 3;
     */
    usage?: Usage;
    constructor(data?: PartialMessage<DiscoverBatchResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DiscoverBatchResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiscoverBatchResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiscoverBatchResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiscoverBatchResponse;
    static equals(a: DiscoverBatchResponse | PlainMessage<DiscoverBatchResponse> | undefined, b: DiscoverBatchResponse | PlainMessage<DiscoverBatchResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.RecommendGroupsResponse
 */
export declare class RecommendGroupsResponse extends Message<RecommendGroupsResponse> {
    /**
     * @generated from field: qdrant.GroupsResult result = 1;
     */
    result?: GroupsResult;
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    /**
     * @generated from field: optional qdrant.Usage usage = 3;
     */
    usage?: Usage;
    constructor(data?: PartialMessage<RecommendGroupsResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.RecommendGroupsResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecommendGroupsResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecommendGroupsResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecommendGroupsResponse;
    static equals(a: RecommendGroupsResponse | PlainMessage<RecommendGroupsResponse> | undefined, b: RecommendGroupsResponse | PlainMessage<RecommendGroupsResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.UpdateBatchResponse
 */
export declare class UpdateBatchResponse extends Message<UpdateBatchResponse> {
    /**
     * @generated from field: repeated qdrant.UpdateResult result = 1;
     */
    result: UpdateResult[];
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    /**
     * @generated from field: optional qdrant.Usage usage = 3;
     */
    usage?: Usage;
    constructor(data?: PartialMessage<UpdateBatchResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.UpdateBatchResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateBatchResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateBatchResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateBatchResponse;
    static equals(a: UpdateBatchResponse | PlainMessage<UpdateBatchResponse> | undefined, b: UpdateBatchResponse | PlainMessage<UpdateBatchResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.FacetResponse
 */
export declare class FacetResponse extends Message<FacetResponse> {
    /**
     * @generated from field: repeated qdrant.FacetHit hits = 1;
     */
    hits: FacetHit[];
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    constructor(data?: PartialMessage<FacetResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.FacetResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FacetResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FacetResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FacetResponse;
    static equals(a: FacetResponse | PlainMessage<FacetResponse> | undefined, b: FacetResponse | PlainMessage<FacetResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.SearchMatrixPairsResponse
 */
export declare class SearchMatrixPairsResponse extends Message<SearchMatrixPairsResponse> {
    /**
     * @generated from field: qdrant.SearchMatrixPairs result = 1;
     */
    result?: SearchMatrixPairs;
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    /**
     * @generated from field: optional qdrant.Usage usage = 3;
     */
    usage?: Usage;
    constructor(data?: PartialMessage<SearchMatrixPairsResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SearchMatrixPairsResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchMatrixPairsResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchMatrixPairsResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchMatrixPairsResponse;
    static equals(a: SearchMatrixPairsResponse | PlainMessage<SearchMatrixPairsResponse> | undefined, b: SearchMatrixPairsResponse | PlainMessage<SearchMatrixPairsResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.SearchMatrixOffsetsResponse
 */
export declare class SearchMatrixOffsetsResponse extends Message<SearchMatrixOffsetsResponse> {
    /**
     * @generated from field: qdrant.SearchMatrixOffsets result = 1;
     */
    result?: SearchMatrixOffsets;
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    /**
     * @generated from field: optional qdrant.Usage usage = 3;
     */
    usage?: Usage;
    constructor(data?: PartialMessage<SearchMatrixOffsetsResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SearchMatrixOffsetsResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchMatrixOffsetsResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchMatrixOffsetsResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchMatrixOffsetsResponse;
    static equals(a: SearchMatrixOffsetsResponse | PlainMessage<SearchMatrixOffsetsResponse> | undefined, b: SearchMatrixOffsetsResponse | PlainMessage<SearchMatrixOffsetsResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.Filter
 */
export declare class Filter extends Message<Filter> {
    /**
     * At least one of those conditions should match
     *
     * @generated from field: repeated qdrant.Condition should = 1;
     */
    should: Condition[];
    /**
     * All conditions must match
     *
     * @generated from field: repeated qdrant.Condition must = 2;
     */
    must: Condition[];
    /**
     * All conditions must NOT match
     *
     * @generated from field: repeated qdrant.Condition must_not = 3;
     */
    mustNot: Condition[];
    /**
     * At least minimum amount of given conditions should match
     *
     * @generated from field: optional qdrant.MinShould min_should = 4;
     */
    minShould?: MinShould;
    constructor(data?: PartialMessage<Filter>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.Filter";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Filter;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Filter;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Filter;
    static equals(a: Filter | PlainMessage<Filter> | undefined, b: Filter | PlainMessage<Filter> | undefined): boolean;
}
/**
 * @generated from message qdrant.MinShould
 */
export declare class MinShould extends Message<MinShould> {
    /**
     * @generated from field: repeated qdrant.Condition conditions = 1;
     */
    conditions: Condition[];
    /**
     * @generated from field: uint64 min_count = 2;
     */
    minCount: bigint;
    constructor(data?: PartialMessage<MinShould>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.MinShould";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MinShould;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MinShould;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MinShould;
    static equals(a: MinShould | PlainMessage<MinShould> | undefined, b: MinShould | PlainMessage<MinShould> | undefined): boolean;
}
/**
 * @generated from message qdrant.Condition
 */
export declare class Condition extends Message<Condition> {
    /**
     * @generated from oneof qdrant.Condition.condition_one_of
     */
    conditionOneOf: {
        /**
         * @generated from field: qdrant.FieldCondition field = 1;
         */
        value: FieldCondition;
        case: "field";
    } | {
        /**
         * @generated from field: qdrant.IsEmptyCondition is_empty = 2;
         */
        value: IsEmptyCondition;
        case: "isEmpty";
    } | {
        /**
         * @generated from field: qdrant.HasIdCondition has_id = 3;
         */
        value: HasIdCondition;
        case: "hasId";
    } | {
        /**
         * @generated from field: qdrant.Filter filter = 4;
         */
        value: Filter;
        case: "filter";
    } | {
        /**
         * @generated from field: qdrant.IsNullCondition is_null = 5;
         */
        value: IsNullCondition;
        case: "isNull";
    } | {
        /**
         * @generated from field: qdrant.NestedCondition nested = 6;
         */
        value: NestedCondition;
        case: "nested";
    } | {
        /**
         * @generated from field: qdrant.HasVectorCondition has_vector = 7;
         */
        value: HasVectorCondition;
        case: "hasVector";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<Condition>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.Condition";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Condition;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Condition;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Condition;
    static equals(a: Condition | PlainMessage<Condition> | undefined, b: Condition | PlainMessage<Condition> | undefined): boolean;
}
/**
 * @generated from message qdrant.IsEmptyCondition
 */
export declare class IsEmptyCondition extends Message<IsEmptyCondition> {
    /**
     * @generated from field: string key = 1;
     */
    key: string;
    constructor(data?: PartialMessage<IsEmptyCondition>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.IsEmptyCondition";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsEmptyCondition;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsEmptyCondition;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsEmptyCondition;
    static equals(a: IsEmptyCondition | PlainMessage<IsEmptyCondition> | undefined, b: IsEmptyCondition | PlainMessage<IsEmptyCondition> | undefined): boolean;
}
/**
 * @generated from message qdrant.IsNullCondition
 */
export declare class IsNullCondition extends Message<IsNullCondition> {
    /**
     * @generated from field: string key = 1;
     */
    key: string;
    constructor(data?: PartialMessage<IsNullCondition>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.IsNullCondition";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsNullCondition;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsNullCondition;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsNullCondition;
    static equals(a: IsNullCondition | PlainMessage<IsNullCondition> | undefined, b: IsNullCondition | PlainMessage<IsNullCondition> | undefined): boolean;
}
/**
 * @generated from message qdrant.HasIdCondition
 */
export declare class HasIdCondition extends Message<HasIdCondition> {
    /**
     * @generated from field: repeated qdrant.PointId has_id = 1;
     */
    hasId: PointId[];
    constructor(data?: PartialMessage<HasIdCondition>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.HasIdCondition";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HasIdCondition;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HasIdCondition;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HasIdCondition;
    static equals(a: HasIdCondition | PlainMessage<HasIdCondition> | undefined, b: HasIdCondition | PlainMessage<HasIdCondition> | undefined): boolean;
}
/**
 * @generated from message qdrant.HasVectorCondition
 */
export declare class HasVectorCondition extends Message<HasVectorCondition> {
    /**
     * @generated from field: string has_vector = 1;
     */
    hasVector: string;
    constructor(data?: PartialMessage<HasVectorCondition>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.HasVectorCondition";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HasVectorCondition;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HasVectorCondition;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HasVectorCondition;
    static equals(a: HasVectorCondition | PlainMessage<HasVectorCondition> | undefined, b: HasVectorCondition | PlainMessage<HasVectorCondition> | undefined): boolean;
}
/**
 * @generated from message qdrant.NestedCondition
 */
export declare class NestedCondition extends Message<NestedCondition> {
    /**
     * Path to nested object
     *
     * @generated from field: string key = 1;
     */
    key: string;
    /**
     * Filter condition
     *
     * @generated from field: qdrant.Filter filter = 2;
     */
    filter?: Filter;
    constructor(data?: PartialMessage<NestedCondition>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.NestedCondition";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NestedCondition;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NestedCondition;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NestedCondition;
    static equals(a: NestedCondition | PlainMessage<NestedCondition> | undefined, b: NestedCondition | PlainMessage<NestedCondition> | undefined): boolean;
}
/**
 * @generated from message qdrant.FieldCondition
 */
export declare class FieldCondition extends Message<FieldCondition> {
    /**
     * @generated from field: string key = 1;
     */
    key: string;
    /**
     * Check if point has field with a given value
     *
     * @generated from field: qdrant.Match match = 2;
     */
    match?: Match;
    /**
     * Check if points value lies in a given range
     *
     * @generated from field: qdrant.Range range = 3;
     */
    range?: Range;
    /**
     * Check if points geolocation lies in a given area
     *
     * @generated from field: qdrant.GeoBoundingBox geo_bounding_box = 4;
     */
    geoBoundingBox?: GeoBoundingBox;
    /**
     * Check if geo point is within a given radius
     *
     * @generated from field: qdrant.GeoRadius geo_radius = 5;
     */
    geoRadius?: GeoRadius;
    /**
     * Check number of values for a specific field
     *
     * @generated from field: qdrant.ValuesCount values_count = 6;
     */
    valuesCount?: ValuesCount;
    /**
     * Check if geo point is within a given polygon
     *
     * @generated from field: qdrant.GeoPolygon geo_polygon = 7;
     */
    geoPolygon?: GeoPolygon;
    /**
     * Check if datetime is within a given range
     *
     * @generated from field: qdrant.DatetimeRange datetime_range = 8;
     */
    datetimeRange?: DatetimeRange;
    /**
     * Check if field is empty
     *
     * @generated from field: optional bool is_empty = 9;
     */
    isEmpty?: boolean;
    /**
     * Check if field is null
     *
     * @generated from field: optional bool is_null = 10;
     */
    isNull?: boolean;
    constructor(data?: PartialMessage<FieldCondition>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.FieldCondition";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldCondition;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldCondition;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldCondition;
    static equals(a: FieldCondition | PlainMessage<FieldCondition> | undefined, b: FieldCondition | PlainMessage<FieldCondition> | undefined): boolean;
}
/**
 * @generated from message qdrant.Match
 */
export declare class Match extends Message<Match> {
    /**
     * @generated from oneof qdrant.Match.match_value
     */
    matchValue: {
        /**
         * Match string keyword
         *
         * @generated from field: string keyword = 1;
         */
        value: string;
        case: "keyword";
    } | {
        /**
         * Match integer
         *
         * @generated from field: int64 integer = 2;
         */
        value: bigint;
        case: "integer";
    } | {
        /**
         * Match boolean
         *
         * @generated from field: bool boolean = 3;
         */
        value: boolean;
        case: "boolean";
    } | {
        /**
         * Match text
         *
         * @generated from field: string text = 4;
         */
        value: string;
        case: "text";
    } | {
        /**
         * Match multiple keywords
         *
         * @generated from field: qdrant.RepeatedStrings keywords = 5;
         */
        value: RepeatedStrings;
        case: "keywords";
    } | {
        /**
         * Match multiple integers
         *
         * @generated from field: qdrant.RepeatedIntegers integers = 6;
         */
        value: RepeatedIntegers;
        case: "integers";
    } | {
        /**
         * Match any other value except those integers
         *
         * @generated from field: qdrant.RepeatedIntegers except_integers = 7;
         */
        value: RepeatedIntegers;
        case: "exceptIntegers";
    } | {
        /**
         * Match any other value except those keywords
         *
         * @generated from field: qdrant.RepeatedStrings except_keywords = 8;
         */
        value: RepeatedStrings;
        case: "exceptKeywords";
    } | {
        /**
         * Match phrase text
         *
         * @generated from field: string phrase = 9;
         */
        value: string;
        case: "phrase";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<Match>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.Match";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Match;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Match;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Match;
    static equals(a: Match | PlainMessage<Match> | undefined, b: Match | PlainMessage<Match> | undefined): boolean;
}
/**
 * @generated from message qdrant.RepeatedStrings
 */
export declare class RepeatedStrings extends Message<RepeatedStrings> {
    /**
     * @generated from field: repeated string strings = 1;
     */
    strings: string[];
    constructor(data?: PartialMessage<RepeatedStrings>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.RepeatedStrings";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedStrings;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedStrings;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedStrings;
    static equals(a: RepeatedStrings | PlainMessage<RepeatedStrings> | undefined, b: RepeatedStrings | PlainMessage<RepeatedStrings> | undefined): boolean;
}
/**
 * @generated from message qdrant.RepeatedIntegers
 */
export declare class RepeatedIntegers extends Message<RepeatedIntegers> {
    /**
     * @generated from field: repeated int64 integers = 1;
     */
    integers: bigint[];
    constructor(data?: PartialMessage<RepeatedIntegers>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.RepeatedIntegers";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedIntegers;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedIntegers;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedIntegers;
    static equals(a: RepeatedIntegers | PlainMessage<RepeatedIntegers> | undefined, b: RepeatedIntegers | PlainMessage<RepeatedIntegers> | undefined): boolean;
}
/**
 * @generated from message qdrant.Range
 */
export declare class Range extends Message<Range> {
    /**
     * @generated from field: optional double lt = 1;
     */
    lt?: number;
    /**
     * @generated from field: optional double gt = 2;
     */
    gt?: number;
    /**
     * @generated from field: optional double gte = 3;
     */
    gte?: number;
    /**
     * @generated from field: optional double lte = 4;
     */
    lte?: number;
    constructor(data?: PartialMessage<Range>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.Range";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Range;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Range;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Range;
    static equals(a: Range | PlainMessage<Range> | undefined, b: Range | PlainMessage<Range> | undefined): boolean;
}
/**
 * @generated from message qdrant.DatetimeRange
 */
export declare class DatetimeRange extends Message<DatetimeRange> {
    /**
     * @generated from field: optional google.protobuf.Timestamp lt = 1;
     */
    lt?: Timestamp;
    /**
     * @generated from field: optional google.protobuf.Timestamp gt = 2;
     */
    gt?: Timestamp;
    /**
     * @generated from field: optional google.protobuf.Timestamp gte = 3;
     */
    gte?: Timestamp;
    /**
     * @generated from field: optional google.protobuf.Timestamp lte = 4;
     */
    lte?: Timestamp;
    constructor(data?: PartialMessage<DatetimeRange>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DatetimeRange";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatetimeRange;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatetimeRange;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatetimeRange;
    static equals(a: DatetimeRange | PlainMessage<DatetimeRange> | undefined, b: DatetimeRange | PlainMessage<DatetimeRange> | undefined): boolean;
}
/**
 * @generated from message qdrant.GeoBoundingBox
 */
export declare class GeoBoundingBox extends Message<GeoBoundingBox> {
    /**
     * north-west corner
     *
     * @generated from field: qdrant.GeoPoint top_left = 1;
     */
    topLeft?: GeoPoint;
    /**
     * south-east corner
     *
     * @generated from field: qdrant.GeoPoint bottom_right = 2;
     */
    bottomRight?: GeoPoint;
    constructor(data?: PartialMessage<GeoBoundingBox>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.GeoBoundingBox";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoBoundingBox;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoBoundingBox;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoBoundingBox;
    static equals(a: GeoBoundingBox | PlainMessage<GeoBoundingBox> | undefined, b: GeoBoundingBox | PlainMessage<GeoBoundingBox> | undefined): boolean;
}
/**
 * @generated from message qdrant.GeoRadius
 */
export declare class GeoRadius extends Message<GeoRadius> {
    /**
     * Center of the circle
     *
     * @generated from field: qdrant.GeoPoint center = 1;
     */
    center?: GeoPoint;
    /**
     * In meters
     *
     * @generated from field: float radius = 2;
     */
    radius: number;
    constructor(data?: PartialMessage<GeoRadius>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.GeoRadius";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoRadius;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoRadius;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoRadius;
    static equals(a: GeoRadius | PlainMessage<GeoRadius> | undefined, b: GeoRadius | PlainMessage<GeoRadius> | undefined): boolean;
}
/**
 * @generated from message qdrant.GeoLineString
 */
export declare class GeoLineString extends Message<GeoLineString> {
    /**
     * Ordered sequence of GeoPoints representing the line
     *
     * @generated from field: repeated qdrant.GeoPoint points = 1;
     */
    points: GeoPoint[];
    constructor(data?: PartialMessage<GeoLineString>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.GeoLineString";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoLineString;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoLineString;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoLineString;
    static equals(a: GeoLineString | PlainMessage<GeoLineString> | undefined, b: GeoLineString | PlainMessage<GeoLineString> | undefined): boolean;
}
/**
 * For a valid GeoPolygon, both the exterior and interior GeoLineStrings must consist of a minimum of 4 points.
 * Additionally, the first and last points of each GeoLineString must be the same.
 *
 * @generated from message qdrant.GeoPolygon
 */
export declare class GeoPolygon extends Message<GeoPolygon> {
    /**
     * The exterior line bounds the surface
     *
     * @generated from field: qdrant.GeoLineString exterior = 1;
     */
    exterior?: GeoLineString;
    /**
     * Interior lines (if present) bound holes within the surface
     *
     * @generated from field: repeated qdrant.GeoLineString interiors = 2;
     */
    interiors: GeoLineString[];
    constructor(data?: PartialMessage<GeoPolygon>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.GeoPolygon";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoPolygon;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoPolygon;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoPolygon;
    static equals(a: GeoPolygon | PlainMessage<GeoPolygon> | undefined, b: GeoPolygon | PlainMessage<GeoPolygon> | undefined): boolean;
}
/**
 * @generated from message qdrant.ValuesCount
 */
export declare class ValuesCount extends Message<ValuesCount> {
    /**
     * @generated from field: optional uint64 lt = 1;
     */
    lt?: bigint;
    /**
     * @generated from field: optional uint64 gt = 2;
     */
    gt?: bigint;
    /**
     * @generated from field: optional uint64 gte = 3;
     */
    gte?: bigint;
    /**
     * @generated from field: optional uint64 lte = 4;
     */
    lte?: bigint;
    constructor(data?: PartialMessage<ValuesCount>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ValuesCount";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValuesCount;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValuesCount;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValuesCount;
    static equals(a: ValuesCount | PlainMessage<ValuesCount> | undefined, b: ValuesCount | PlainMessage<ValuesCount> | undefined): boolean;
}
/**
 * @generated from message qdrant.PointsSelector
 */
export declare class PointsSelector extends Message<PointsSelector> {
    /**
     * @generated from oneof qdrant.PointsSelector.points_selector_one_of
     */
    pointsSelectorOneOf: {
        /**
         * @generated from field: qdrant.PointsIdsList points = 1;
         */
        value: PointsIdsList;
        case: "points";
    } | {
        /**
         * @generated from field: qdrant.Filter filter = 2;
         */
        value: Filter;
        case: "filter";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<PointsSelector>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PointsSelector";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointsSelector;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointsSelector;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointsSelector;
    static equals(a: PointsSelector | PlainMessage<PointsSelector> | undefined, b: PointsSelector | PlainMessage<PointsSelector> | undefined): boolean;
}
/**
 * @generated from message qdrant.PointsIdsList
 */
export declare class PointsIdsList extends Message<PointsIdsList> {
    /**
     * @generated from field: repeated qdrant.PointId ids = 1;
     */
    ids: PointId[];
    constructor(data?: PartialMessage<PointsIdsList>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PointsIdsList";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointsIdsList;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointsIdsList;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointsIdsList;
    static equals(a: PointsIdsList | PlainMessage<PointsIdsList> | undefined, b: PointsIdsList | PlainMessage<PointsIdsList> | undefined): boolean;
}
/**
 * @generated from message qdrant.PointStruct
 */
export declare class PointStruct extends Message<PointStruct> {
    /**
     * @generated from field: qdrant.PointId id = 1;
     */
    id?: PointId;
    /**
     * @generated from field: map<string, qdrant.Value> payload = 3;
     */
    payload: {
        [key: string]: Value;
    };
    /**
     * @generated from field: optional qdrant.Vectors vectors = 4;
     */
    vectors?: Vectors;
    constructor(data?: PartialMessage<PointStruct>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PointStruct";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointStruct;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointStruct;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointStruct;
    static equals(a: PointStruct | PlainMessage<PointStruct> | undefined, b: PointStruct | PlainMessage<PointStruct> | undefined): boolean;
}
/**
 * @generated from message qdrant.GeoPoint
 */
export declare class GeoPoint extends Message<GeoPoint> {
    /**
     * @generated from field: double lon = 1;
     */
    lon: number;
    /**
     * @generated from field: double lat = 2;
     */
    lat: number;
    constructor(data?: PartialMessage<GeoPoint>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.GeoPoint";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoPoint;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoPoint;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoPoint;
    static equals(a: GeoPoint | PlainMessage<GeoPoint> | undefined, b: GeoPoint | PlainMessage<GeoPoint> | undefined): boolean;
}
/**
 * ---------------------------------------------
 * ----------- Measurements collector ----------
 * ---------------------------------------------
 *
 * @generated from message qdrant.Usage
 */
export declare class Usage extends Message<Usage> {
    /**
     * @generated from field: optional qdrant.HardwareUsage hardware = 1;
     */
    hardware?: HardwareUsage;
    /**
     * @generated from field: optional qdrant.InferenceUsage inference = 2;
     */
    inference?: InferenceUsage;
    constructor(data?: PartialMessage<Usage>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.Usage";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Usage;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Usage;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Usage;
    static equals(a: Usage | PlainMessage<Usage> | undefined, b: Usage | PlainMessage<Usage> | undefined): boolean;
}
/**
 * @generated from message qdrant.InferenceUsage
 */
export declare class InferenceUsage extends Message<InferenceUsage> {
    /**
     * @generated from field: map<string, qdrant.ModelUsage> models = 1;
     */
    models: {
        [key: string]: ModelUsage;
    };
    constructor(data?: PartialMessage<InferenceUsage>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.InferenceUsage";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InferenceUsage;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InferenceUsage;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InferenceUsage;
    static equals(a: InferenceUsage | PlainMessage<InferenceUsage> | undefined, b: InferenceUsage | PlainMessage<InferenceUsage> | undefined): boolean;
}
/**
 * @generated from message qdrant.ModelUsage
 */
export declare class ModelUsage extends Message<ModelUsage> {
    /**
     * @generated from field: uint64 tokens = 1;
     */
    tokens: bigint;
    constructor(data?: PartialMessage<ModelUsage>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ModelUsage";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelUsage;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelUsage;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelUsage;
    static equals(a: ModelUsage | PlainMessage<ModelUsage> | undefined, b: ModelUsage | PlainMessage<ModelUsage> | undefined): boolean;
}
/**
 * @generated from message qdrant.HardwareUsage
 */
export declare class HardwareUsage extends Message<HardwareUsage> {
    /**
     * @generated from field: uint64 cpu = 1;
     */
    cpu: bigint;
    /**
     * @generated from field: uint64 payload_io_read = 2;
     */
    payloadIoRead: bigint;
    /**
     * @generated from field: uint64 payload_io_write = 3;
     */
    payloadIoWrite: bigint;
    /**
     * @generated from field: uint64 payload_index_io_read = 4;
     */
    payloadIndexIoRead: bigint;
    /**
     * @generated from field: uint64 payload_index_io_write = 5;
     */
    payloadIndexIoWrite: bigint;
    /**
     * @generated from field: uint64 vector_io_read = 6;
     */
    vectorIoRead: bigint;
    /**
     * @generated from field: uint64 vector_io_write = 7;
     */
    vectorIoWrite: bigint;
    constructor(data?: PartialMessage<HardwareUsage>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.HardwareUsage";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HardwareUsage;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HardwareUsage;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HardwareUsage;
    static equals(a: HardwareUsage | PlainMessage<HardwareUsage> | undefined, b: HardwareUsage | PlainMessage<HardwareUsage> | undefined): boolean;
}
