import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
/**
 * @generated from enum qdrant.Datatype
 */
export declare enum Datatype {
    /**
     * @generated from enum value: Default = 0;
     */
    Default = 0,
    /**
     * @generated from enum value: Float32 = 1;
     */
    Float32 = 1,
    /**
     * @generated from enum value: Uint8 = 2;
     */
    Uint8 = 2,
    /**
     * @generated from enum value: Float16 = 3;
     */
    Float16 = 3
}
/**
 * @generated from enum qdrant.Modifier
 */
export declare enum Modifier {
    /**
     * @generated from enum value: None = 0;
     */
    None = 0,
    /**
     * Apply Inverse Document Frequency
     *
     * @generated from enum value: Idf = 1;
     */
    Idf = 1
}
/**
 * @generated from enum qdrant.MultiVectorComparator
 */
export declare enum MultiVectorComparator {
    /**
     * @generated from enum value: MaxSim = 0;
     */
    MaxSim = 0
}
/**
 * @generated from enum qdrant.Distance
 */
export declare enum Distance {
    /**
     * @generated from enum value: UnknownDistance = 0;
     */
    UnknownDistance = 0,
    /**
     * @generated from enum value: Cosine = 1;
     */
    Cosine = 1,
    /**
     * @generated from enum value: Euclid = 2;
     */
    Euclid = 2,
    /**
     * @generated from enum value: Dot = 3;
     */
    Dot = 3,
    /**
     * @generated from enum value: Manhattan = 4;
     */
    Manhattan = 4
}
/**
 * @generated from enum qdrant.CollectionStatus
 */
export declare enum CollectionStatus {
    /**
     * @generated from enum value: UnknownCollectionStatus = 0;
     */
    UnknownCollectionStatus = 0,
    /**
     * All segments are ready
     *
     * @generated from enum value: Green = 1;
     */
    Green = 1,
    /**
     * Optimization in process
     *
     * @generated from enum value: Yellow = 2;
     */
    Yellow = 2,
    /**
     * Something went wrong
     *
     * @generated from enum value: Red = 3;
     */
    Red = 3,
    /**
     * Optimization is pending
     *
     * @generated from enum value: Grey = 4;
     */
    Grey = 4
}
/**
 * @generated from enum qdrant.PayloadSchemaType
 */
export declare enum PayloadSchemaType {
    /**
     * @generated from enum value: UnknownType = 0;
     */
    UnknownType = 0,
    /**
     * @generated from enum value: Keyword = 1;
     */
    Keyword = 1,
    /**
     * @generated from enum value: Integer = 2;
     */
    Integer = 2,
    /**
     * @generated from enum value: Float = 3;
     */
    Float = 3,
    /**
     * @generated from enum value: Geo = 4;
     */
    Geo = 4,
    /**
     * @generated from enum value: Text = 5;
     */
    Text = 5,
    /**
     * @generated from enum value: Bool = 6;
     */
    Bool = 6,
    /**
     * @generated from enum value: Datetime = 7;
     */
    Datetime = 7,
    /**
     * @generated from enum value: Uuid = 8;
     */
    Uuid = 8
}
/**
 * @generated from enum qdrant.QuantizationType
 */
export declare enum QuantizationType {
    /**
     * @generated from enum value: UnknownQuantization = 0;
     */
    UnknownQuantization = 0,
    /**
     * @generated from enum value: Int8 = 1;
     */
    Int8 = 1
}
/**
 * @generated from enum qdrant.CompressionRatio
 */
export declare enum CompressionRatio {
    /**
     * @generated from enum value: x4 = 0;
     */
    x4 = 0,
    /**
     * @generated from enum value: x8 = 1;
     */
    x8 = 1,
    /**
     * @generated from enum value: x16 = 2;
     */
    x16 = 2,
    /**
     * @generated from enum value: x32 = 3;
     */
    x32 = 3,
    /**
     * @generated from enum value: x64 = 4;
     */
    x64 = 4
}
/**
 * @generated from enum qdrant.BinaryQuantizationEncoding
 */
export declare enum BinaryQuantizationEncoding {
    /**
     * @generated from enum value: OneBit = 0;
     */
    OneBit = 0,
    /**
     * @generated from enum value: TwoBits = 1;
     */
    TwoBits = 1,
    /**
     * @generated from enum value: OneAndHalfBits = 2;
     */
    OneAndHalfBits = 2
}
/**
 * @generated from enum qdrant.ShardingMethod
 */
export declare enum ShardingMethod {
    /**
     * Auto-sharding based on record ids
     *
     * @generated from enum value: Auto = 0;
     */
    Auto = 0,
    /**
     * Shard by user-defined key
     *
     * @generated from enum value: Custom = 1;
     */
    Custom = 1
}
/**
 * @generated from enum qdrant.TokenizerType
 */
export declare enum TokenizerType {
    /**
     * @generated from enum value: Unknown = 0;
     */
    Unknown = 0,
    /**
     * @generated from enum value: Prefix = 1;
     */
    Prefix = 1,
    /**
     * @generated from enum value: Whitespace = 2;
     */
    Whitespace = 2,
    /**
     * @generated from enum value: Word = 3;
     */
    Word = 3,
    /**
     * @generated from enum value: Multilingual = 4;
     */
    Multilingual = 4
}
/**
 * @generated from enum qdrant.ReplicaState
 */
export declare enum ReplicaState {
    /**
     * Active and sound
     *
     * @generated from enum value: Active = 0;
     */
    Active = 0,
    /**
     * Failed for some reason
     *
     * @generated from enum value: Dead = 1;
     */
    Dead = 1,
    /**
     * The shard is partially loaded and is currently receiving data from other shards
     *
     * @generated from enum value: Partial = 2;
     */
    Partial = 2,
    /**
     * Collection is being created
     *
     * @generated from enum value: Initializing = 3;
     */
    Initializing = 3,
    /**
     * A shard which receives data, but is not used for search; Useful for backup shards
     *
     * @generated from enum value: Listener = 4;
     */
    Listener = 4,
    /**
     * Deprecated: snapshot shard transfer is in progress; Updates should not be sent to (and are ignored by) the shard
     *
     * @generated from enum value: PartialSnapshot = 5;
     */
    PartialSnapshot = 5,
    /**
     * Shard is undergoing recovered by an external node; Normally rejects updates, accepts updates if force is true
     *
     * @generated from enum value: Recovery = 6;
     */
    Recovery = 6,
    /**
     * Points are being migrated to this shard as part of scale-up resharding
     *
     * @generated from enum value: Resharding = 7;
     */
    Resharding = 7,
    /**
     * Points are being migrated to this shard as part of scale-down resharding
     *
     * @generated from enum value: ReshardingScaleDown = 8;
     */
    ReshardingScaleDown = 8
}
/**
 *
 * Resharding direction, scale up or down in number of shards
 *
 * @generated from enum qdrant.ReshardingDirection
 */
export declare enum ReshardingDirection {
    /**
     * Scale up, add a new shard
     *
     * @generated from enum value: Up = 0;
     */
    Up = 0,
    /**
     * Scale down, remove a shard
     *
     * @generated from enum value: Down = 1;
     */
    Down = 1
}
/**
 * @generated from enum qdrant.ShardTransferMethod
 */
export declare enum ShardTransferMethod {
    /**
     * Stream shard records in batches
     *
     * @generated from enum value: StreamRecords = 0;
     */
    StreamRecords = 0,
    /**
     * Snapshot the shard and recover it on the target peer
     *
     * @generated from enum value: Snapshot = 1;
     */
    Snapshot = 1,
    /**
     * Resolve WAL delta between peers and transfer the difference
     *
     * @generated from enum value: WalDelta = 2;
     */
    WalDelta = 2,
    /**
     * Stream shard records in batches for resharding
     *
     * @generated from enum value: ReshardingStreamRecords = 3;
     */
    ReshardingStreamRecords = 3
}
/**
 * @generated from message qdrant.VectorParams
 */
export declare class VectorParams extends Message<VectorParams> {
    /**
     * Size of the vectors
     *
     * @generated from field: uint64 size = 1;
     */
    size: bigint;
    /**
     * Distance function used for comparing vectors
     *
     * @generated from field: qdrant.Distance distance = 2;
     */
    distance: Distance;
    /**
     * Configuration of vector HNSW graph. If omitted - the collection configuration will be used
     *
     * @generated from field: optional qdrant.HnswConfigDiff hnsw_config = 3;
     */
    hnswConfig?: HnswConfigDiff;
    /**
     * Configuration of vector quantization config. If omitted - the collection configuration will be used
     *
     * @generated from field: optional qdrant.QuantizationConfig quantization_config = 4;
     */
    quantizationConfig?: QuantizationConfig;
    /**
     * If true - serve vectors from disk. If set to false, the vectors will be loaded in RAM.
     *
     * @generated from field: optional bool on_disk = 5;
     */
    onDisk?: boolean;
    /**
     * Data type of the vectors
     *
     * @generated from field: optional qdrant.Datatype datatype = 6;
     */
    datatype?: Datatype;
    /**
     * Configuration for multi-vector search
     *
     * @generated from field: optional qdrant.MultiVectorConfig multivector_config = 7;
     */
    multivectorConfig?: MultiVectorConfig;
    constructor(data?: PartialMessage<VectorParams>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.VectorParams";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VectorParams;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VectorParams;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VectorParams;
    static equals(a: VectorParams | PlainMessage<VectorParams> | undefined, b: VectorParams | PlainMessage<VectorParams> | undefined): boolean;
}
/**
 * @generated from message qdrant.VectorParamsDiff
 */
export declare class VectorParamsDiff extends Message<VectorParamsDiff> {
    /**
     * Update params for HNSW index. If empty object - it will be unset
     *
     * @generated from field: optional qdrant.HnswConfigDiff hnsw_config = 1;
     */
    hnswConfig?: HnswConfigDiff;
    /**
     * Update quantization params. If none - it is left unchanged.
     *
     * @generated from field: optional qdrant.QuantizationConfigDiff quantization_config = 2;
     */
    quantizationConfig?: QuantizationConfigDiff;
    /**
     * If true - serve vectors from disk. If set to false, the vectors will be loaded in RAM.
     *
     * @generated from field: optional bool on_disk = 3;
     */
    onDisk?: boolean;
    constructor(data?: PartialMessage<VectorParamsDiff>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.VectorParamsDiff";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VectorParamsDiff;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VectorParamsDiff;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VectorParamsDiff;
    static equals(a: VectorParamsDiff | PlainMessage<VectorParamsDiff> | undefined, b: VectorParamsDiff | PlainMessage<VectorParamsDiff> | undefined): boolean;
}
/**
 * @generated from message qdrant.VectorParamsMap
 */
export declare class VectorParamsMap extends Message<VectorParamsMap> {
    /**
     * @generated from field: map<string, qdrant.VectorParams> map = 1;
     */
    map: {
        [key: string]: VectorParams;
    };
    constructor(data?: PartialMessage<VectorParamsMap>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.VectorParamsMap";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VectorParamsMap;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VectorParamsMap;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VectorParamsMap;
    static equals(a: VectorParamsMap | PlainMessage<VectorParamsMap> | undefined, b: VectorParamsMap | PlainMessage<VectorParamsMap> | undefined): boolean;
}
/**
 * @generated from message qdrant.VectorParamsDiffMap
 */
export declare class VectorParamsDiffMap extends Message<VectorParamsDiffMap> {
    /**
     * @generated from field: map<string, qdrant.VectorParamsDiff> map = 1;
     */
    map: {
        [key: string]: VectorParamsDiff;
    };
    constructor(data?: PartialMessage<VectorParamsDiffMap>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.VectorParamsDiffMap";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VectorParamsDiffMap;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VectorParamsDiffMap;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VectorParamsDiffMap;
    static equals(a: VectorParamsDiffMap | PlainMessage<VectorParamsDiffMap> | undefined, b: VectorParamsDiffMap | PlainMessage<VectorParamsDiffMap> | undefined): boolean;
}
/**
 * @generated from message qdrant.VectorsConfig
 */
export declare class VectorsConfig extends Message<VectorsConfig> {
    /**
     * @generated from oneof qdrant.VectorsConfig.config
     */
    config: {
        /**
         * @generated from field: qdrant.VectorParams params = 1;
         */
        value: VectorParams;
        case: "params";
    } | {
        /**
         * @generated from field: qdrant.VectorParamsMap params_map = 2;
         */
        value: VectorParamsMap;
        case: "paramsMap";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<VectorsConfig>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.VectorsConfig";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VectorsConfig;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VectorsConfig;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VectorsConfig;
    static equals(a: VectorsConfig | PlainMessage<VectorsConfig> | undefined, b: VectorsConfig | PlainMessage<VectorsConfig> | undefined): boolean;
}
/**
 * @generated from message qdrant.VectorsConfigDiff
 */
export declare class VectorsConfigDiff extends Message<VectorsConfigDiff> {
    /**
     * @generated from oneof qdrant.VectorsConfigDiff.config
     */
    config: {
        /**
         * @generated from field: qdrant.VectorParamsDiff params = 1;
         */
        value: VectorParamsDiff;
        case: "params";
    } | {
        /**
         * @generated from field: qdrant.VectorParamsDiffMap params_map = 2;
         */
        value: VectorParamsDiffMap;
        case: "paramsMap";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<VectorsConfigDiff>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.VectorsConfigDiff";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VectorsConfigDiff;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VectorsConfigDiff;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VectorsConfigDiff;
    static equals(a: VectorsConfigDiff | PlainMessage<VectorsConfigDiff> | undefined, b: VectorsConfigDiff | PlainMessage<VectorsConfigDiff> | undefined): boolean;
}
/**
 * @generated from message qdrant.SparseVectorParams
 */
export declare class SparseVectorParams extends Message<SparseVectorParams> {
    /**
     * Configuration of sparse index
     *
     * @generated from field: optional qdrant.SparseIndexConfig index = 1;
     */
    index?: SparseIndexConfig;
    /**
     * If set - apply modifier to the vector values
     *
     * @generated from field: optional qdrant.Modifier modifier = 2;
     */
    modifier?: Modifier;
    constructor(data?: PartialMessage<SparseVectorParams>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SparseVectorParams";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SparseVectorParams;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SparseVectorParams;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SparseVectorParams;
    static equals(a: SparseVectorParams | PlainMessage<SparseVectorParams> | undefined, b: SparseVectorParams | PlainMessage<SparseVectorParams> | undefined): boolean;
}
/**
 * @generated from message qdrant.SparseVectorConfig
 */
export declare class SparseVectorConfig extends Message<SparseVectorConfig> {
    /**
     * @generated from field: map<string, qdrant.SparseVectorParams> map = 1;
     */
    map: {
        [key: string]: SparseVectorParams;
    };
    constructor(data?: PartialMessage<SparseVectorConfig>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SparseVectorConfig";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SparseVectorConfig;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SparseVectorConfig;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SparseVectorConfig;
    static equals(a: SparseVectorConfig | PlainMessage<SparseVectorConfig> | undefined, b: SparseVectorConfig | PlainMessage<SparseVectorConfig> | undefined): boolean;
}
/**
 * @generated from message qdrant.MultiVectorConfig
 */
export declare class MultiVectorConfig extends Message<MultiVectorConfig> {
    /**
     * Comparator for multi-vector search
     *
     * @generated from field: qdrant.MultiVectorComparator comparator = 1;
     */
    comparator: MultiVectorComparator;
    constructor(data?: PartialMessage<MultiVectorConfig>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.MultiVectorConfig";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MultiVectorConfig;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MultiVectorConfig;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MultiVectorConfig;
    static equals(a: MultiVectorConfig | PlainMessage<MultiVectorConfig> | undefined, b: MultiVectorConfig | PlainMessage<MultiVectorConfig> | undefined): boolean;
}
/**
 * @generated from message qdrant.GetCollectionInfoRequest
 */
export declare class GetCollectionInfoRequest extends Message<GetCollectionInfoRequest> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    constructor(data?: PartialMessage<GetCollectionInfoRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.GetCollectionInfoRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCollectionInfoRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCollectionInfoRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCollectionInfoRequest;
    static equals(a: GetCollectionInfoRequest | PlainMessage<GetCollectionInfoRequest> | undefined, b: GetCollectionInfoRequest | PlainMessage<GetCollectionInfoRequest> | undefined): boolean;
}
/**
 * @generated from message qdrant.CollectionExistsRequest
 */
export declare class CollectionExistsRequest extends Message<CollectionExistsRequest> {
    /**
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    constructor(data?: PartialMessage<CollectionExistsRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CollectionExistsRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionExistsRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionExistsRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionExistsRequest;
    static equals(a: CollectionExistsRequest | PlainMessage<CollectionExistsRequest> | undefined, b: CollectionExistsRequest | PlainMessage<CollectionExistsRequest> | undefined): boolean;
}
/**
 * @generated from message qdrant.CollectionExists
 */
export declare class CollectionExists extends Message<CollectionExists> {
    /**
     * @generated from field: bool exists = 1;
     */
    exists: boolean;
    constructor(data?: PartialMessage<CollectionExists>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CollectionExists";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionExists;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionExists;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionExists;
    static equals(a: CollectionExists | PlainMessage<CollectionExists> | undefined, b: CollectionExists | PlainMessage<CollectionExists> | undefined): boolean;
}
/**
 * @generated from message qdrant.CollectionExistsResponse
 */
export declare class CollectionExistsResponse extends Message<CollectionExistsResponse> {
    /**
     * @generated from field: qdrant.CollectionExists result = 1;
     */
    result?: CollectionExists;
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    constructor(data?: PartialMessage<CollectionExistsResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CollectionExistsResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionExistsResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionExistsResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionExistsResponse;
    static equals(a: CollectionExistsResponse | PlainMessage<CollectionExistsResponse> | undefined, b: CollectionExistsResponse | PlainMessage<CollectionExistsResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.ListCollectionsRequest
 */
export declare class ListCollectionsRequest extends Message<ListCollectionsRequest> {
    constructor(data?: PartialMessage<ListCollectionsRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ListCollectionsRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListCollectionsRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListCollectionsRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListCollectionsRequest;
    static equals(a: ListCollectionsRequest | PlainMessage<ListCollectionsRequest> | undefined, b: ListCollectionsRequest | PlainMessage<ListCollectionsRequest> | undefined): boolean;
}
/**
 * @generated from message qdrant.CollectionDescription
 */
export declare class CollectionDescription extends Message<CollectionDescription> {
    /**
     * Name of the collection
     *
     * @generated from field: string name = 1;
     */
    name: string;
    constructor(data?: PartialMessage<CollectionDescription>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CollectionDescription";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionDescription;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionDescription;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionDescription;
    static equals(a: CollectionDescription | PlainMessage<CollectionDescription> | undefined, b: CollectionDescription | PlainMessage<CollectionDescription> | undefined): boolean;
}
/**
 * @generated from message qdrant.GetCollectionInfoResponse
 */
export declare class GetCollectionInfoResponse extends Message<GetCollectionInfoResponse> {
    /**
     * @generated from field: qdrant.CollectionInfo result = 1;
     */
    result?: CollectionInfo;
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    constructor(data?: PartialMessage<GetCollectionInfoResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.GetCollectionInfoResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCollectionInfoResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCollectionInfoResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCollectionInfoResponse;
    static equals(a: GetCollectionInfoResponse | PlainMessage<GetCollectionInfoResponse> | undefined, b: GetCollectionInfoResponse | PlainMessage<GetCollectionInfoResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.ListCollectionsResponse
 */
export declare class ListCollectionsResponse extends Message<ListCollectionsResponse> {
    /**
     * @generated from field: repeated qdrant.CollectionDescription collections = 1;
     */
    collections: CollectionDescription[];
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    constructor(data?: PartialMessage<ListCollectionsResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ListCollectionsResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListCollectionsResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListCollectionsResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListCollectionsResponse;
    static equals(a: ListCollectionsResponse | PlainMessage<ListCollectionsResponse> | undefined, b: ListCollectionsResponse | PlainMessage<ListCollectionsResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.MaxOptimizationThreads
 */
export declare class MaxOptimizationThreads extends Message<MaxOptimizationThreads> {
    /**
     * @generated from oneof qdrant.MaxOptimizationThreads.variant
     */
    variant: {
        /**
         * @generated from field: uint64 value = 1;
         */
        value: bigint;
        case: "value";
    } | {
        /**
         * @generated from field: qdrant.MaxOptimizationThreads.Setting setting = 2;
         */
        value: MaxOptimizationThreads_Setting;
        case: "setting";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<MaxOptimizationThreads>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.MaxOptimizationThreads";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MaxOptimizationThreads;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MaxOptimizationThreads;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MaxOptimizationThreads;
    static equals(a: MaxOptimizationThreads | PlainMessage<MaxOptimizationThreads> | undefined, b: MaxOptimizationThreads | PlainMessage<MaxOptimizationThreads> | undefined): boolean;
}
/**
 * @generated from enum qdrant.MaxOptimizationThreads.Setting
 */
export declare enum MaxOptimizationThreads_Setting {
    /**
     * @generated from enum value: Auto = 0;
     */
    Auto = 0
}
/**
 * @generated from message qdrant.OptimizerStatus
 */
export declare class OptimizerStatus extends Message<OptimizerStatus> {
    /**
     * @generated from field: bool ok = 1;
     */
    ok: boolean;
    /**
     * @generated from field: string error = 2;
     */
    error: string;
    constructor(data?: PartialMessage<OptimizerStatus>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.OptimizerStatus";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OptimizerStatus;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OptimizerStatus;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OptimizerStatus;
    static equals(a: OptimizerStatus | PlainMessage<OptimizerStatus> | undefined, b: OptimizerStatus | PlainMessage<OptimizerStatus> | undefined): boolean;
}
/**
 * @generated from message qdrant.HnswConfigDiff
 */
export declare class HnswConfigDiff extends Message<HnswConfigDiff> {
    /**
     *
     * Number of edges per node in the index graph. Larger the value - more accurate the search, more space required.
     *
     * @generated from field: optional uint64 m = 1;
     */
    m?: bigint;
    /**
     *
     * Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build the index.
     *
     * @generated from field: optional uint64 ef_construct = 2;
     */
    efConstruct?: bigint;
    /**
     *
     * Minimal size (in KiloBytes) of vectors for additional payload-based indexing.
     * If the payload chunk is smaller than `full_scan_threshold` additional indexing won't be used -
     * in this case full-scan search should be preferred by query planner and additional indexing is not required.
     * Note: 1 Kb = 1 vector of size 256
     *
     * @generated from field: optional uint64 full_scan_threshold = 3;
     */
    fullScanThreshold?: bigint;
    /**
     *
     * Number of parallel threads used for background index building.
     * If 0 - automatically select from 8 to 16.
     * Best to keep between 8 and 16 to prevent likelihood of building broken/inefficient HNSW graphs.
     * On small CPUs, less threads are used.
     *
     * @generated from field: optional uint64 max_indexing_threads = 4;
     */
    maxIndexingThreads?: bigint;
    /**
     *
     * Store HNSW index on disk. If set to false, the index will be stored in RAM.
     *
     * @generated from field: optional bool on_disk = 5;
     */
    onDisk?: boolean;
    /**
     *
     * Number of additional payload-aware links per node in the index graph. If not set - regular M parameter will be used.
     *
     * @generated from field: optional uint64 payload_m = 6;
     */
    payloadM?: bigint;
    constructor(data?: PartialMessage<HnswConfigDiff>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.HnswConfigDiff";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HnswConfigDiff;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HnswConfigDiff;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HnswConfigDiff;
    static equals(a: HnswConfigDiff | PlainMessage<HnswConfigDiff> | undefined, b: HnswConfigDiff | PlainMessage<HnswConfigDiff> | undefined): boolean;
}
/**
 * @generated from message qdrant.SparseIndexConfig
 */
export declare class SparseIndexConfig extends Message<SparseIndexConfig> {
    /**
     *
     * Prefer a full scan search upto (excluding) this number of vectors.
     * Note: this is number of vectors, not KiloBytes.
     *
     * @generated from field: optional uint64 full_scan_threshold = 1;
     */
    fullScanThreshold?: bigint;
    /**
     *
     * Store inverted index on disk. If set to false, the index will be stored in RAM.
     *
     * @generated from field: optional bool on_disk = 2;
     */
    onDisk?: boolean;
    /**
     *
     * Datatype used to store weights in the index.
     *
     * @generated from field: optional qdrant.Datatype datatype = 3;
     */
    datatype?: Datatype;
    constructor(data?: PartialMessage<SparseIndexConfig>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SparseIndexConfig";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SparseIndexConfig;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SparseIndexConfig;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SparseIndexConfig;
    static equals(a: SparseIndexConfig | PlainMessage<SparseIndexConfig> | undefined, b: SparseIndexConfig | PlainMessage<SparseIndexConfig> | undefined): boolean;
}
/**
 * @generated from message qdrant.WalConfigDiff
 */
export declare class WalConfigDiff extends Message<WalConfigDiff> {
    /**
     * Size of a single WAL block file
     *
     * @generated from field: optional uint64 wal_capacity_mb = 1;
     */
    walCapacityMb?: bigint;
    /**
     * Number of segments to create in advance
     *
     * @generated from field: optional uint64 wal_segments_ahead = 2;
     */
    walSegmentsAhead?: bigint;
    constructor(data?: PartialMessage<WalConfigDiff>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.WalConfigDiff";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WalConfigDiff;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WalConfigDiff;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WalConfigDiff;
    static equals(a: WalConfigDiff | PlainMessage<WalConfigDiff> | undefined, b: WalConfigDiff | PlainMessage<WalConfigDiff> | undefined): boolean;
}
/**
 * @generated from message qdrant.OptimizersConfigDiff
 */
export declare class OptimizersConfigDiff extends Message<OptimizersConfigDiff> {
    /**
     *
     * The minimal fraction of deleted vectors in a segment, required to perform segment optimization
     *
     * @generated from field: optional double deleted_threshold = 1;
     */
    deletedThreshold?: number;
    /**
     *
     * The minimal number of vectors in a segment, required to perform segment optimization
     *
     * @generated from field: optional uint64 vacuum_min_vector_number = 2;
     */
    vacuumMinVectorNumber?: bigint;
    /**
     *
     * Target amount of segments the optimizer will try to keep.
     * Real amount of segments may vary depending on multiple parameters:
     *
     * - Amount of stored points.
     * - Current write RPS.
     *
     * It is recommended to select the default number of segments as a factor of the number of search threads,
     * so that each segment would be handled evenly by one of the threads.
     *
     * @generated from field: optional uint64 default_segment_number = 3;
     */
    defaultSegmentNumber?: bigint;
    /**
     *
     * Deprecated:
     *
     * Do not create segments larger this size (in kilobytes).
     * Large segments might require disproportionately long indexation times,
     * therefore it makes sense to limit the size of segments.
     *
     * If indexing speed is more important - make this parameter lower.
     * If search speed is more important - make this parameter higher.
     * Note: 1Kb = 1 vector of size 256
     * If not set, will be automatically selected considering the number of available CPUs.
     *
     * @generated from field: optional uint64 max_segment_size = 4;
     */
    maxSegmentSize?: bigint;
    /**
     *
     * Maximum size (in kilobytes) of vectors to store in-memory per segment.
     * Segments larger than this threshold will be stored as read-only memmapped file.
     *
     * Memmap storage is disabled by default, to enable it, set this threshold to a reasonable value.
     *
     * To disable memmap storage, set this to `0`.
     *
     * Note: 1Kb = 1 vector of size 256
     *
     * @generated from field: optional uint64 memmap_threshold = 5;
     */
    memmapThreshold?: bigint;
    /**
     *
     * Maximum size (in kilobytes) of vectors allowed for plain index, exceeding this threshold will enable vector indexing
     *
     * Default value is 20,000, based on <https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md>.
     *
     * To disable vector indexing, set to `0`.
     *
     * Note: 1kB = 1 vector of size 256.
     *
     * @generated from field: optional uint64 indexing_threshold = 6;
     */
    indexingThreshold?: bigint;
    /**
     *
     * Interval between forced flushes.
     *
     * @generated from field: optional uint64 flush_interval_sec = 7;
     */
    flushIntervalSec?: bigint;
    /**
     * Deprecated in favor of `max_optimization_threads`
     *
     * @generated from field: optional uint64 deprecated_max_optimization_threads = 8;
     */
    deprecatedMaxOptimizationThreads?: bigint;
    /**
     *
     * Max number of threads (jobs) for running optimizations per shard.
     * Note: each optimization job will also use `max_indexing_threads` threads by itself for index building.
     * If "auto" - have no limit and choose dynamically to saturate CPU.
     * If 0 - no optimization threads, optimizations will be disabled.
     *
     * @generated from field: optional qdrant.MaxOptimizationThreads max_optimization_threads = 9;
     */
    maxOptimizationThreads?: MaxOptimizationThreads;
    constructor(data?: PartialMessage<OptimizersConfigDiff>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.OptimizersConfigDiff";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OptimizersConfigDiff;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OptimizersConfigDiff;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OptimizersConfigDiff;
    static equals(a: OptimizersConfigDiff | PlainMessage<OptimizersConfigDiff> | undefined, b: OptimizersConfigDiff | PlainMessage<OptimizersConfigDiff> | undefined): boolean;
}
/**
 * @generated from message qdrant.ScalarQuantization
 */
export declare class ScalarQuantization extends Message<ScalarQuantization> {
    /**
     * Type of quantization
     *
     * @generated from field: qdrant.QuantizationType type = 1;
     */
    type: QuantizationType;
    /**
     * Number of bits to use for quantization
     *
     * @generated from field: optional float quantile = 2;
     */
    quantile?: number;
    /**
     * If true - quantized vectors always will be stored in RAM, ignoring the config of main storage
     *
     * @generated from field: optional bool always_ram = 3;
     */
    alwaysRam?: boolean;
    constructor(data?: PartialMessage<ScalarQuantization>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ScalarQuantization";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScalarQuantization;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScalarQuantization;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScalarQuantization;
    static equals(a: ScalarQuantization | PlainMessage<ScalarQuantization> | undefined, b: ScalarQuantization | PlainMessage<ScalarQuantization> | undefined): boolean;
}
/**
 * @generated from message qdrant.ProductQuantization
 */
export declare class ProductQuantization extends Message<ProductQuantization> {
    /**
     * Compression ratio
     *
     * @generated from field: qdrant.CompressionRatio compression = 1;
     */
    compression: CompressionRatio;
    /**
     * If true - quantized vectors always will be stored in RAM, ignoring the config of main storage
     *
     * @generated from field: optional bool always_ram = 2;
     */
    alwaysRam?: boolean;
    constructor(data?: PartialMessage<ProductQuantization>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ProductQuantization";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProductQuantization;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProductQuantization;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProductQuantization;
    static equals(a: ProductQuantization | PlainMessage<ProductQuantization> | undefined, b: ProductQuantization | PlainMessage<ProductQuantization> | undefined): boolean;
}
/**
 * @generated from message qdrant.BinaryQuantizationQueryEncoding
 */
export declare class BinaryQuantizationQueryEncoding extends Message<BinaryQuantizationQueryEncoding> {
    /**
     * @generated from oneof qdrant.BinaryQuantizationQueryEncoding.variant
     */
    variant: {
        /**
         * @generated from field: qdrant.BinaryQuantizationQueryEncoding.Setting setting = 4;
         */
        value: BinaryQuantizationQueryEncoding_Setting;
        case: "setting";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<BinaryQuantizationQueryEncoding>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.BinaryQuantizationQueryEncoding";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BinaryQuantizationQueryEncoding;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BinaryQuantizationQueryEncoding;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BinaryQuantizationQueryEncoding;
    static equals(a: BinaryQuantizationQueryEncoding | PlainMessage<BinaryQuantizationQueryEncoding> | undefined, b: BinaryQuantizationQueryEncoding | PlainMessage<BinaryQuantizationQueryEncoding> | undefined): boolean;
}
/**
 * @generated from enum qdrant.BinaryQuantizationQueryEncoding.Setting
 */
export declare enum BinaryQuantizationQueryEncoding_Setting {
    /**
     * @generated from enum value: Default = 0;
     */
    Default = 0,
    /**
     * @generated from enum value: Binary = 1;
     */
    Binary = 1,
    /**
     * @generated from enum value: Scalar4Bits = 2;
     */
    Scalar4Bits = 2,
    /**
     * @generated from enum value: Scalar8Bits = 3;
     */
    Scalar8Bits = 3
}
/**
 * @generated from message qdrant.BinaryQuantization
 */
export declare class BinaryQuantization extends Message<BinaryQuantization> {
    /**
     * If true - quantized vectors always will be stored in RAM, ignoring the config of main storage
     *
     * @generated from field: optional bool always_ram = 1;
     */
    alwaysRam?: boolean;
    /**
     * Binary quantization encoding method
     *
     * @generated from field: optional qdrant.BinaryQuantizationEncoding encoding = 2;
     */
    encoding?: BinaryQuantizationEncoding;
    /**
     *
     * Asymmetric quantization configuration allows a query to have different quantization than stored vectors.
     * It can increase the accuracy of search at the cost of performance.
     *
     * @generated from field: optional qdrant.BinaryQuantizationQueryEncoding query_encoding = 3;
     */
    queryEncoding?: BinaryQuantizationQueryEncoding;
    constructor(data?: PartialMessage<BinaryQuantization>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.BinaryQuantization";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BinaryQuantization;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BinaryQuantization;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BinaryQuantization;
    static equals(a: BinaryQuantization | PlainMessage<BinaryQuantization> | undefined, b: BinaryQuantization | PlainMessage<BinaryQuantization> | undefined): boolean;
}
/**
 * @generated from message qdrant.QuantizationConfig
 */
export declare class QuantizationConfig extends Message<QuantizationConfig> {
    /**
     * @generated from oneof qdrant.QuantizationConfig.quantization
     */
    quantization: {
        /**
         * @generated from field: qdrant.ScalarQuantization scalar = 1;
         */
        value: ScalarQuantization;
        case: "scalar";
    } | {
        /**
         * @generated from field: qdrant.ProductQuantization product = 2;
         */
        value: ProductQuantization;
        case: "product";
    } | {
        /**
         * @generated from field: qdrant.BinaryQuantization binary = 3;
         */
        value: BinaryQuantization;
        case: "binary";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<QuantizationConfig>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.QuantizationConfig";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuantizationConfig;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuantizationConfig;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuantizationConfig;
    static equals(a: QuantizationConfig | PlainMessage<QuantizationConfig> | undefined, b: QuantizationConfig | PlainMessage<QuantizationConfig> | undefined): boolean;
}
/**
 * @generated from message qdrant.Disabled
 */
export declare class Disabled extends Message<Disabled> {
    constructor(data?: PartialMessage<Disabled>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.Disabled";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Disabled;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Disabled;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Disabled;
    static equals(a: Disabled | PlainMessage<Disabled> | undefined, b: Disabled | PlainMessage<Disabled> | undefined): boolean;
}
/**
 * @generated from message qdrant.QuantizationConfigDiff
 */
export declare class QuantizationConfigDiff extends Message<QuantizationConfigDiff> {
    /**
     * @generated from oneof qdrant.QuantizationConfigDiff.quantization
     */
    quantization: {
        /**
         * @generated from field: qdrant.ScalarQuantization scalar = 1;
         */
        value: ScalarQuantization;
        case: "scalar";
    } | {
        /**
         * @generated from field: qdrant.ProductQuantization product = 2;
         */
        value: ProductQuantization;
        case: "product";
    } | {
        /**
         * @generated from field: qdrant.Disabled disabled = 3;
         */
        value: Disabled;
        case: "disabled";
    } | {
        /**
         * @generated from field: qdrant.BinaryQuantization binary = 4;
         */
        value: BinaryQuantization;
        case: "binary";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<QuantizationConfigDiff>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.QuantizationConfigDiff";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuantizationConfigDiff;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuantizationConfigDiff;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuantizationConfigDiff;
    static equals(a: QuantizationConfigDiff | PlainMessage<QuantizationConfigDiff> | undefined, b: QuantizationConfigDiff | PlainMessage<QuantizationConfigDiff> | undefined): boolean;
}
/**
 * @generated from message qdrant.StrictModeConfig
 */
export declare class StrictModeConfig extends Message<StrictModeConfig> {
    /**
     * @generated from field: optional bool enabled = 1;
     */
    enabled?: boolean;
    /**
     * @generated from field: optional uint32 max_query_limit = 2;
     */
    maxQueryLimit?: number;
    /**
     * @generated from field: optional uint32 max_timeout = 3;
     */
    maxTimeout?: number;
    /**
     * @generated from field: optional bool unindexed_filtering_retrieve = 4;
     */
    unindexedFilteringRetrieve?: boolean;
    /**
     * @generated from field: optional bool unindexed_filtering_update = 5;
     */
    unindexedFilteringUpdate?: boolean;
    /**
     * @generated from field: optional uint32 search_max_hnsw_ef = 6;
     */
    searchMaxHnswEf?: number;
    /**
     * @generated from field: optional bool search_allow_exact = 7;
     */
    searchAllowExact?: boolean;
    /**
     * @generated from field: optional float search_max_oversampling = 8;
     */
    searchMaxOversampling?: number;
    /**
     * @generated from field: optional uint64 upsert_max_batchsize = 9;
     */
    upsertMaxBatchsize?: bigint;
    /**
     * @generated from field: optional uint64 max_collection_vector_size_bytes = 10;
     */
    maxCollectionVectorSizeBytes?: bigint;
    /**
     * Max number of read operations per minute per replica
     *
     * @generated from field: optional uint32 read_rate_limit = 11;
     */
    readRateLimit?: number;
    /**
     * Max number of write operations per minute per replica
     *
     * @generated from field: optional uint32 write_rate_limit = 12;
     */
    writeRateLimit?: number;
    /**
     * @generated from field: optional uint64 max_collection_payload_size_bytes = 13;
     */
    maxCollectionPayloadSizeBytes?: bigint;
    /**
     * @generated from field: optional uint64 filter_max_conditions = 14;
     */
    filterMaxConditions?: bigint;
    /**
     * @generated from field: optional uint64 condition_max_size = 15;
     */
    conditionMaxSize?: bigint;
    /**
     * @generated from field: optional qdrant.StrictModeMultivectorConfig multivector_config = 16;
     */
    multivectorConfig?: StrictModeMultivectorConfig;
    /**
     * @generated from field: optional qdrant.StrictModeSparseConfig sparse_config = 17;
     */
    sparseConfig?: StrictModeSparseConfig;
    /**
     * @generated from field: optional uint64 max_points_count = 18;
     */
    maxPointsCount?: bigint;
    constructor(data?: PartialMessage<StrictModeConfig>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.StrictModeConfig";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StrictModeConfig;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StrictModeConfig;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StrictModeConfig;
    static equals(a: StrictModeConfig | PlainMessage<StrictModeConfig> | undefined, b: StrictModeConfig | PlainMessage<StrictModeConfig> | undefined): boolean;
}
/**
 * @generated from message qdrant.StrictModeSparseConfig
 */
export declare class StrictModeSparseConfig extends Message<StrictModeSparseConfig> {
    /**
     * @generated from field: map<string, qdrant.StrictModeSparse> sparse_config = 1;
     */
    sparseConfig: {
        [key: string]: StrictModeSparse;
    };
    constructor(data?: PartialMessage<StrictModeSparseConfig>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.StrictModeSparseConfig";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StrictModeSparseConfig;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StrictModeSparseConfig;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StrictModeSparseConfig;
    static equals(a: StrictModeSparseConfig | PlainMessage<StrictModeSparseConfig> | undefined, b: StrictModeSparseConfig | PlainMessage<StrictModeSparseConfig> | undefined): boolean;
}
/**
 * @generated from message qdrant.StrictModeSparse
 */
export declare class StrictModeSparse extends Message<StrictModeSparse> {
    /**
     * @generated from field: optional uint64 max_length = 10;
     */
    maxLength?: bigint;
    constructor(data?: PartialMessage<StrictModeSparse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.StrictModeSparse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StrictModeSparse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StrictModeSparse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StrictModeSparse;
    static equals(a: StrictModeSparse | PlainMessage<StrictModeSparse> | undefined, b: StrictModeSparse | PlainMessage<StrictModeSparse> | undefined): boolean;
}
/**
 * @generated from message qdrant.StrictModeMultivectorConfig
 */
export declare class StrictModeMultivectorConfig extends Message<StrictModeMultivectorConfig> {
    /**
     * @generated from field: map<string, qdrant.StrictModeMultivector> multivector_config = 1;
     */
    multivectorConfig: {
        [key: string]: StrictModeMultivector;
    };
    constructor(data?: PartialMessage<StrictModeMultivectorConfig>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.StrictModeMultivectorConfig";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StrictModeMultivectorConfig;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StrictModeMultivectorConfig;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StrictModeMultivectorConfig;
    static equals(a: StrictModeMultivectorConfig | PlainMessage<StrictModeMultivectorConfig> | undefined, b: StrictModeMultivectorConfig | PlainMessage<StrictModeMultivectorConfig> | undefined): boolean;
}
/**
 * @generated from message qdrant.StrictModeMultivector
 */
export declare class StrictModeMultivector extends Message<StrictModeMultivector> {
    /**
     * @generated from field: optional uint64 max_vectors = 1;
     */
    maxVectors?: bigint;
    constructor(data?: PartialMessage<StrictModeMultivector>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.StrictModeMultivector";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StrictModeMultivector;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StrictModeMultivector;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StrictModeMultivector;
    static equals(a: StrictModeMultivector | PlainMessage<StrictModeMultivector> | undefined, b: StrictModeMultivector | PlainMessage<StrictModeMultivector> | undefined): boolean;
}
/**
 * @generated from message qdrant.CreateCollection
 */
export declare class CreateCollection extends Message<CreateCollection> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Configuration of vector index
     *
     * @generated from field: optional qdrant.HnswConfigDiff hnsw_config = 4;
     */
    hnswConfig?: HnswConfigDiff;
    /**
     * Configuration of the Write-Ahead-Log
     *
     * @generated from field: optional qdrant.WalConfigDiff wal_config = 5;
     */
    walConfig?: WalConfigDiff;
    /**
     * Configuration of the optimizers
     *
     * @generated from field: optional qdrant.OptimizersConfigDiff optimizers_config = 6;
     */
    optimizersConfig?: OptimizersConfigDiff;
    /**
     * Number of shards in the collection, default is 1 for standalone, otherwise equal to the number of nodes. Minimum is 1
     *
     * @generated from field: optional uint32 shard_number = 7;
     */
    shardNumber?: number;
    /**
     * If true - point's payload will not be stored in memory
     *
     * @generated from field: optional bool on_disk_payload = 8;
     */
    onDiskPayload?: boolean;
    /**
     * Wait timeout for operation commit in seconds, if not specified - default value will be supplied
     *
     * @generated from field: optional uint64 timeout = 9;
     */
    timeout?: bigint;
    /**
     * Configuration for vectors
     *
     * @generated from field: optional qdrant.VectorsConfig vectors_config = 10;
     */
    vectorsConfig?: VectorsConfig;
    /**
     * Number of replicas of each shard that network tries to maintain, default = 1
     *
     * @generated from field: optional uint32 replication_factor = 11;
     */
    replicationFactor?: number;
    /**
     * How many replicas should apply the operation for us to consider it successful, default = 1
     *
     * @generated from field: optional uint32 write_consistency_factor = 12;
     */
    writeConsistencyFactor?: number;
    /**
     * Deprecated: specify name of the other collection to copy data from
     *
     * @generated from field: optional string init_from_collection = 13;
     */
    initFromCollection?: string;
    /**
     * Quantization configuration of vector
     *
     * @generated from field: optional qdrant.QuantizationConfig quantization_config = 14;
     */
    quantizationConfig?: QuantizationConfig;
    /**
     * Sharding method
     *
     * @generated from field: optional qdrant.ShardingMethod sharding_method = 15;
     */
    shardingMethod?: ShardingMethod;
    /**
     * Configuration for sparse vectors
     *
     * @generated from field: optional qdrant.SparseVectorConfig sparse_vectors_config = 16;
     */
    sparseVectorsConfig?: SparseVectorConfig;
    /**
     * Configuration for strict mode
     *
     * @generated from field: optional qdrant.StrictModeConfig strict_mode_config = 17;
     */
    strictModeConfig?: StrictModeConfig;
    constructor(data?: PartialMessage<CreateCollection>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CreateCollection";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateCollection;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateCollection;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateCollection;
    static equals(a: CreateCollection | PlainMessage<CreateCollection> | undefined, b: CreateCollection | PlainMessage<CreateCollection> | undefined): boolean;
}
/**
 * @generated from message qdrant.UpdateCollection
 */
export declare class UpdateCollection extends Message<UpdateCollection> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * New configuration parameters for the collection. This operation is blocking, it will only proceed once all current optimizations are complete
     *
     * @generated from field: optional qdrant.OptimizersConfigDiff optimizers_config = 2;
     */
    optimizersConfig?: OptimizersConfigDiff;
    /**
     * Wait timeout for operation commit in seconds if blocking, if not specified - default value will be supplied
     *
     * @generated from field: optional uint64 timeout = 3;
     */
    timeout?: bigint;
    /**
     * New configuration parameters for the collection
     *
     * @generated from field: optional qdrant.CollectionParamsDiff params = 4;
     */
    params?: CollectionParamsDiff;
    /**
     * New HNSW parameters for the collection index
     *
     * @generated from field: optional qdrant.HnswConfigDiff hnsw_config = 5;
     */
    hnswConfig?: HnswConfigDiff;
    /**
     * New vector parameters
     *
     * @generated from field: optional qdrant.VectorsConfigDiff vectors_config = 6;
     */
    vectorsConfig?: VectorsConfigDiff;
    /**
     * Quantization configuration of vector
     *
     * @generated from field: optional qdrant.QuantizationConfigDiff quantization_config = 7;
     */
    quantizationConfig?: QuantizationConfigDiff;
    /**
     * New sparse vector parameters
     *
     * @generated from field: optional qdrant.SparseVectorConfig sparse_vectors_config = 8;
     */
    sparseVectorsConfig?: SparseVectorConfig;
    /**
     * New strict mode configuration
     *
     * @generated from field: optional qdrant.StrictModeConfig strict_mode_config = 9;
     */
    strictModeConfig?: StrictModeConfig;
    constructor(data?: PartialMessage<UpdateCollection>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.UpdateCollection";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateCollection;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateCollection;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateCollection;
    static equals(a: UpdateCollection | PlainMessage<UpdateCollection> | undefined, b: UpdateCollection | PlainMessage<UpdateCollection> | undefined): boolean;
}
/**
 * @generated from message qdrant.DeleteCollection
 */
export declare class DeleteCollection extends Message<DeleteCollection> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Wait timeout for operation commit in seconds, if not specified - default value will be supplied
     *
     * @generated from field: optional uint64 timeout = 2;
     */
    timeout?: bigint;
    constructor(data?: PartialMessage<DeleteCollection>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DeleteCollection";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteCollection;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteCollection;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteCollection;
    static equals(a: DeleteCollection | PlainMessage<DeleteCollection> | undefined, b: DeleteCollection | PlainMessage<DeleteCollection> | undefined): boolean;
}
/**
 * @generated from message qdrant.CollectionOperationResponse
 */
export declare class CollectionOperationResponse extends Message<CollectionOperationResponse> {
    /**
     * if operation made changes
     *
     * @generated from field: bool result = 1;
     */
    result: boolean;
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    constructor(data?: PartialMessage<CollectionOperationResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CollectionOperationResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionOperationResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionOperationResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionOperationResponse;
    static equals(a: CollectionOperationResponse | PlainMessage<CollectionOperationResponse> | undefined, b: CollectionOperationResponse | PlainMessage<CollectionOperationResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.CollectionParams
 */
export declare class CollectionParams extends Message<CollectionParams> {
    /**
     * Number of shards in collection
     *
     * @generated from field: uint32 shard_number = 3;
     */
    shardNumber: number;
    /**
     * If true - point's payload will not be stored in memory
     *
     * @generated from field: bool on_disk_payload = 4;
     */
    onDiskPayload: boolean;
    /**
     * Configuration for vectors
     *
     * @generated from field: optional qdrant.VectorsConfig vectors_config = 5;
     */
    vectorsConfig?: VectorsConfig;
    /**
     * Number of replicas of each shard that network tries to maintain
     *
     * @generated from field: optional uint32 replication_factor = 6;
     */
    replicationFactor?: number;
    /**
     * How many replicas should apply the operation for us to consider it successful
     *
     * @generated from field: optional uint32 write_consistency_factor = 7;
     */
    writeConsistencyFactor?: number;
    /**
     * Fan-out every read request to these many additional remote nodes (and return first available response)
     *
     * @generated from field: optional uint32 read_fan_out_factor = 8;
     */
    readFanOutFactor?: number;
    /**
     * Sharding method
     *
     * @generated from field: optional qdrant.ShardingMethod sharding_method = 9;
     */
    shardingMethod?: ShardingMethod;
    /**
     * Configuration for sparse vectors
     *
     * @generated from field: optional qdrant.SparseVectorConfig sparse_vectors_config = 10;
     */
    sparseVectorsConfig?: SparseVectorConfig;
    constructor(data?: PartialMessage<CollectionParams>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CollectionParams";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionParams;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionParams;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionParams;
    static equals(a: CollectionParams | PlainMessage<CollectionParams> | undefined, b: CollectionParams | PlainMessage<CollectionParams> | undefined): boolean;
}
/**
 * @generated from message qdrant.CollectionParamsDiff
 */
export declare class CollectionParamsDiff extends Message<CollectionParamsDiff> {
    /**
     * Number of replicas of each shard that network tries to maintain
     *
     * @generated from field: optional uint32 replication_factor = 1;
     */
    replicationFactor?: number;
    /**
     * How many replicas should apply the operation for us to consider it successful
     *
     * @generated from field: optional uint32 write_consistency_factor = 2;
     */
    writeConsistencyFactor?: number;
    /**
     * If true - point's payload will not be stored in memory
     *
     * @generated from field: optional bool on_disk_payload = 3;
     */
    onDiskPayload?: boolean;
    /**
     * Fan-out every read request to these many additional remote nodes (and return first available response)
     *
     * @generated from field: optional uint32 read_fan_out_factor = 4;
     */
    readFanOutFactor?: number;
    constructor(data?: PartialMessage<CollectionParamsDiff>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CollectionParamsDiff";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionParamsDiff;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionParamsDiff;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionParamsDiff;
    static equals(a: CollectionParamsDiff | PlainMessage<CollectionParamsDiff> | undefined, b: CollectionParamsDiff | PlainMessage<CollectionParamsDiff> | undefined): boolean;
}
/**
 * @generated from message qdrant.CollectionConfig
 */
export declare class CollectionConfig extends Message<CollectionConfig> {
    /**
     * Collection parameters
     *
     * @generated from field: qdrant.CollectionParams params = 1;
     */
    params?: CollectionParams;
    /**
     * Configuration of vector index
     *
     * @generated from field: qdrant.HnswConfigDiff hnsw_config = 2;
     */
    hnswConfig?: HnswConfigDiff;
    /**
     * Configuration of the optimizers
     *
     * @generated from field: qdrant.OptimizersConfigDiff optimizer_config = 3;
     */
    optimizerConfig?: OptimizersConfigDiff;
    /**
     * Configuration of the Write-Ahead-Log
     *
     * @generated from field: qdrant.WalConfigDiff wal_config = 4;
     */
    walConfig?: WalConfigDiff;
    /**
     * Configuration of the vector quantization
     *
     * @generated from field: optional qdrant.QuantizationConfig quantization_config = 5;
     */
    quantizationConfig?: QuantizationConfig;
    /**
     * Configuration of strict mode.
     *
     * @generated from field: optional qdrant.StrictModeConfig strict_mode_config = 6;
     */
    strictModeConfig?: StrictModeConfig;
    constructor(data?: PartialMessage<CollectionConfig>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CollectionConfig";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionConfig;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionConfig;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionConfig;
    static equals(a: CollectionConfig | PlainMessage<CollectionConfig> | undefined, b: CollectionConfig | PlainMessage<CollectionConfig> | undefined): boolean;
}
/**
 * @generated from message qdrant.KeywordIndexParams
 */
export declare class KeywordIndexParams extends Message<KeywordIndexParams> {
    /**
     * If true - used for tenant optimization.
     *
     * @generated from field: optional bool is_tenant = 1;
     */
    isTenant?: boolean;
    /**
     * If true - store index on disk.
     *
     * @generated from field: optional bool on_disk = 2;
     */
    onDisk?: boolean;
    constructor(data?: PartialMessage<KeywordIndexParams>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.KeywordIndexParams";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeywordIndexParams;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeywordIndexParams;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeywordIndexParams;
    static equals(a: KeywordIndexParams | PlainMessage<KeywordIndexParams> | undefined, b: KeywordIndexParams | PlainMessage<KeywordIndexParams> | undefined): boolean;
}
/**
 * @generated from message qdrant.IntegerIndexParams
 */
export declare class IntegerIndexParams extends Message<IntegerIndexParams> {
    /**
     * If true - support direct lookups. Default is true.
     *
     * @generated from field: optional bool lookup = 1;
     */
    lookup?: boolean;
    /**
     * If true - support ranges filters. Default is true.
     *
     * @generated from field: optional bool range = 2;
     */
    range?: boolean;
    /**
     * If true - use this key to organize storage of the collection data. This option assumes that this key will be used in majority of filtered requests. Default is false.
     *
     * @generated from field: optional bool is_principal = 3;
     */
    isPrincipal?: boolean;
    /**
     * If true - store index on disk. Default is false.
     *
     * @generated from field: optional bool on_disk = 4;
     */
    onDisk?: boolean;
    constructor(data?: PartialMessage<IntegerIndexParams>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.IntegerIndexParams";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntegerIndexParams;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntegerIndexParams;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntegerIndexParams;
    static equals(a: IntegerIndexParams | PlainMessage<IntegerIndexParams> | undefined, b: IntegerIndexParams | PlainMessage<IntegerIndexParams> | undefined): boolean;
}
/**
 * @generated from message qdrant.FloatIndexParams
 */
export declare class FloatIndexParams extends Message<FloatIndexParams> {
    /**
     * If true - store index on disk.
     *
     * @generated from field: optional bool on_disk = 1;
     */
    onDisk?: boolean;
    /**
     * If true - use this key to organize storage of the collection data. This option assumes that this key will be used in majority of filtered requests.
     *
     * @generated from field: optional bool is_principal = 2;
     */
    isPrincipal?: boolean;
    constructor(data?: PartialMessage<FloatIndexParams>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.FloatIndexParams";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FloatIndexParams;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FloatIndexParams;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FloatIndexParams;
    static equals(a: FloatIndexParams | PlainMessage<FloatIndexParams> | undefined, b: FloatIndexParams | PlainMessage<FloatIndexParams> | undefined): boolean;
}
/**
 * @generated from message qdrant.GeoIndexParams
 */
export declare class GeoIndexParams extends Message<GeoIndexParams> {
    /**
     * If true - store index on disk.
     *
     * @generated from field: optional bool on_disk = 1;
     */
    onDisk?: boolean;
    constructor(data?: PartialMessage<GeoIndexParams>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.GeoIndexParams";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoIndexParams;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoIndexParams;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoIndexParams;
    static equals(a: GeoIndexParams | PlainMessage<GeoIndexParams> | undefined, b: GeoIndexParams | PlainMessage<GeoIndexParams> | undefined): boolean;
}
/**
 * @generated from message qdrant.StopwordsSet
 */
export declare class StopwordsSet extends Message<StopwordsSet> {
    /**
     * List of languages to use stopwords from
     *
     * @generated from field: repeated string languages = 1;
     */
    languages: string[];
    /**
     * List of custom stopwords
     *
     * @generated from field: repeated string custom = 2;
     */
    custom: string[];
    constructor(data?: PartialMessage<StopwordsSet>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.StopwordsSet";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StopwordsSet;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StopwordsSet;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StopwordsSet;
    static equals(a: StopwordsSet | PlainMessage<StopwordsSet> | undefined, b: StopwordsSet | PlainMessage<StopwordsSet> | undefined): boolean;
}
/**
 * @generated from message qdrant.TextIndexParams
 */
export declare class TextIndexParams extends Message<TextIndexParams> {
    /**
     * Tokenizer type
     *
     * @generated from field: qdrant.TokenizerType tokenizer = 1;
     */
    tokenizer: TokenizerType;
    /**
     * If true - all tokens will be lowercase
     *
     * @generated from field: optional bool lowercase = 2;
     */
    lowercase?: boolean;
    /**
     * Minimal token length
     *
     * @generated from field: optional uint64 min_token_len = 3;
     */
    minTokenLen?: bigint;
    /**
     * Maximal token length
     *
     * @generated from field: optional uint64 max_token_len = 4;
     */
    maxTokenLen?: bigint;
    /**
     * If true - store index on disk.
     *
     * @generated from field: optional bool on_disk = 5;
     */
    onDisk?: boolean;
    /**
     * Stopwords for the text index
     *
     * @generated from field: optional qdrant.StopwordsSet stopwords = 6;
     */
    stopwords?: StopwordsSet;
    /**
     * If true - support phrase matching.
     *
     * @generated from field: optional bool phrase_matching = 7;
     */
    phraseMatching?: boolean;
    /**
     * Set an algorithm for stemming.
     *
     * @generated from field: optional qdrant.StemmingAlgorithm stemmer = 8;
     */
    stemmer?: StemmingAlgorithm;
    constructor(data?: PartialMessage<TextIndexParams>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.TextIndexParams";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextIndexParams;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextIndexParams;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextIndexParams;
    static equals(a: TextIndexParams | PlainMessage<TextIndexParams> | undefined, b: TextIndexParams | PlainMessage<TextIndexParams> | undefined): boolean;
}
/**
 * @generated from message qdrant.StemmingAlgorithm
 */
export declare class StemmingAlgorithm extends Message<StemmingAlgorithm> {
    /**
     * @generated from oneof qdrant.StemmingAlgorithm.stemming_params
     */
    stemmingParams: {
        /**
         * Parameters for snowball stemming
         *
         * @generated from field: qdrant.SnowballParams snowball = 1;
         */
        value: SnowballParams;
        case: "snowball";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<StemmingAlgorithm>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.StemmingAlgorithm";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StemmingAlgorithm;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StemmingAlgorithm;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StemmingAlgorithm;
    static equals(a: StemmingAlgorithm | PlainMessage<StemmingAlgorithm> | undefined, b: StemmingAlgorithm | PlainMessage<StemmingAlgorithm> | undefined): boolean;
}
/**
 * @generated from message qdrant.SnowballParams
 */
export declare class SnowballParams extends Message<SnowballParams> {
    /**
     * Which language the algorithm should stem.
     *
     * @generated from field: string language = 1;
     */
    language: string;
    constructor(data?: PartialMessage<SnowballParams>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.SnowballParams";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SnowballParams;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SnowballParams;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SnowballParams;
    static equals(a: SnowballParams | PlainMessage<SnowballParams> | undefined, b: SnowballParams | PlainMessage<SnowballParams> | undefined): boolean;
}
/**
 * @generated from message qdrant.BoolIndexParams
 */
export declare class BoolIndexParams extends Message<BoolIndexParams> {
    /**
     * If true - store index on disk.
     *
     * @generated from field: optional bool on_disk = 1;
     */
    onDisk?: boolean;
    constructor(data?: PartialMessage<BoolIndexParams>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.BoolIndexParams";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BoolIndexParams;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BoolIndexParams;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BoolIndexParams;
    static equals(a: BoolIndexParams | PlainMessage<BoolIndexParams> | undefined, b: BoolIndexParams | PlainMessage<BoolIndexParams> | undefined): boolean;
}
/**
 * @generated from message qdrant.DatetimeIndexParams
 */
export declare class DatetimeIndexParams extends Message<DatetimeIndexParams> {
    /**
     * If true - store index on disk.
     *
     * @generated from field: optional bool on_disk = 1;
     */
    onDisk?: boolean;
    /**
     * If true - use this key to organize storage of the collection data. This option assumes that this key will be used in majority of filtered requests.
     *
     * @generated from field: optional bool is_principal = 2;
     */
    isPrincipal?: boolean;
    constructor(data?: PartialMessage<DatetimeIndexParams>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DatetimeIndexParams";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatetimeIndexParams;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatetimeIndexParams;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatetimeIndexParams;
    static equals(a: DatetimeIndexParams | PlainMessage<DatetimeIndexParams> | undefined, b: DatetimeIndexParams | PlainMessage<DatetimeIndexParams> | undefined): boolean;
}
/**
 * @generated from message qdrant.UuidIndexParams
 */
export declare class UuidIndexParams extends Message<UuidIndexParams> {
    /**
     * If true - used for tenant optimization.
     *
     * @generated from field: optional bool is_tenant = 1;
     */
    isTenant?: boolean;
    /**
     * If true - store index on disk.
     *
     * @generated from field: optional bool on_disk = 2;
     */
    onDisk?: boolean;
    constructor(data?: PartialMessage<UuidIndexParams>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.UuidIndexParams";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UuidIndexParams;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UuidIndexParams;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UuidIndexParams;
    static equals(a: UuidIndexParams | PlainMessage<UuidIndexParams> | undefined, b: UuidIndexParams | PlainMessage<UuidIndexParams> | undefined): boolean;
}
/**
 * @generated from message qdrant.PayloadIndexParams
 */
export declare class PayloadIndexParams extends Message<PayloadIndexParams> {
    /**
     * @generated from oneof qdrant.PayloadIndexParams.index_params
     */
    indexParams: {
        /**
         * Parameters for keyword index
         *
         * @generated from field: qdrant.KeywordIndexParams keyword_index_params = 3;
         */
        value: KeywordIndexParams;
        case: "keywordIndexParams";
    } | {
        /**
         * Parameters for integer index
         *
         * @generated from field: qdrant.IntegerIndexParams integer_index_params = 2;
         */
        value: IntegerIndexParams;
        case: "integerIndexParams";
    } | {
        /**
         * Parameters for float index
         *
         * @generated from field: qdrant.FloatIndexParams float_index_params = 4;
         */
        value: FloatIndexParams;
        case: "floatIndexParams";
    } | {
        /**
         * Parameters for geo index
         *
         * @generated from field: qdrant.GeoIndexParams geo_index_params = 5;
         */
        value: GeoIndexParams;
        case: "geoIndexParams";
    } | {
        /**
         * Parameters for text index
         *
         * @generated from field: qdrant.TextIndexParams text_index_params = 1;
         */
        value: TextIndexParams;
        case: "textIndexParams";
    } | {
        /**
         * Parameters for bool index
         *
         * @generated from field: qdrant.BoolIndexParams bool_index_params = 6;
         */
        value: BoolIndexParams;
        case: "boolIndexParams";
    } | {
        /**
         * Parameters for datetime index
         *
         * @generated from field: qdrant.DatetimeIndexParams datetime_index_params = 7;
         */
        value: DatetimeIndexParams;
        case: "datetimeIndexParams";
    } | {
        /**
         * Parameters for uuid index
         *
         * @generated from field: qdrant.UuidIndexParams uuid_index_params = 8;
         */
        value: UuidIndexParams;
        case: "uuidIndexParams";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<PayloadIndexParams>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PayloadIndexParams";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PayloadIndexParams;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PayloadIndexParams;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PayloadIndexParams;
    static equals(a: PayloadIndexParams | PlainMessage<PayloadIndexParams> | undefined, b: PayloadIndexParams | PlainMessage<PayloadIndexParams> | undefined): boolean;
}
/**
 * @generated from message qdrant.PayloadSchemaInfo
 */
export declare class PayloadSchemaInfo extends Message<PayloadSchemaInfo> {
    /**
     * Field data type
     *
     * @generated from field: qdrant.PayloadSchemaType data_type = 1;
     */
    dataType: PayloadSchemaType;
    /**
     * Field index parameters
     *
     * @generated from field: optional qdrant.PayloadIndexParams params = 2;
     */
    params?: PayloadIndexParams;
    /**
     * Number of points indexed within this field indexed
     *
     * @generated from field: optional uint64 points = 3;
     */
    points?: bigint;
    constructor(data?: PartialMessage<PayloadSchemaInfo>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.PayloadSchemaInfo";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PayloadSchemaInfo;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PayloadSchemaInfo;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PayloadSchemaInfo;
    static equals(a: PayloadSchemaInfo | PlainMessage<PayloadSchemaInfo> | undefined, b: PayloadSchemaInfo | PlainMessage<PayloadSchemaInfo> | undefined): boolean;
}
/**
 * @generated from message qdrant.CollectionInfo
 */
export declare class CollectionInfo extends Message<CollectionInfo> {
    /**
     * operating condition of the collection
     *
     * @generated from field: qdrant.CollectionStatus status = 1;
     */
    status: CollectionStatus;
    /**
     * status of collection optimizers
     *
     * @generated from field: qdrant.OptimizerStatus optimizer_status = 2;
     */
    optimizerStatus?: OptimizerStatus;
    /**
     * Approximate number of vectors in the collection
     *
     * @generated from field: optional uint64 vectors_count = 3;
     */
    vectorsCount?: bigint;
    /**
     * Number of independent segments
     *
     * @generated from field: uint64 segments_count = 4;
     */
    segmentsCount: bigint;
    /**
     * Configuration
     *
     * @generated from field: qdrant.CollectionConfig config = 7;
     */
    config?: CollectionConfig;
    /**
     * Collection data types
     *
     * @generated from field: map<string, qdrant.PayloadSchemaInfo> payload_schema = 8;
     */
    payloadSchema: {
        [key: string]: PayloadSchemaInfo;
    };
    /**
     * Approximate number of points in the collection
     *
     * @generated from field: optional uint64 points_count = 9;
     */
    pointsCount?: bigint;
    /**
     * Approximate number of indexed vectors in the collection.
     *
     * @generated from field: optional uint64 indexed_vectors_count = 10;
     */
    indexedVectorsCount?: bigint;
    constructor(data?: PartialMessage<CollectionInfo>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CollectionInfo";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionInfo;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionInfo;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionInfo;
    static equals(a: CollectionInfo | PlainMessage<CollectionInfo> | undefined, b: CollectionInfo | PlainMessage<CollectionInfo> | undefined): boolean;
}
/**
 * @generated from message qdrant.ChangeAliases
 */
export declare class ChangeAliases extends Message<ChangeAliases> {
    /**
     * List of actions
     *
     * @generated from field: repeated qdrant.AliasOperations actions = 1;
     */
    actions: AliasOperations[];
    /**
     * Wait timeout for operation commit in seconds, if not specified - default value will be supplied
     *
     * @generated from field: optional uint64 timeout = 2;
     */
    timeout?: bigint;
    constructor(data?: PartialMessage<ChangeAliases>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ChangeAliases";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChangeAliases;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChangeAliases;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChangeAliases;
    static equals(a: ChangeAliases | PlainMessage<ChangeAliases> | undefined, b: ChangeAliases | PlainMessage<ChangeAliases> | undefined): boolean;
}
/**
 * @generated from message qdrant.AliasOperations
 */
export declare class AliasOperations extends Message<AliasOperations> {
    /**
     * @generated from oneof qdrant.AliasOperations.action
     */
    action: {
        /**
         * @generated from field: qdrant.CreateAlias create_alias = 1;
         */
        value: CreateAlias;
        case: "createAlias";
    } | {
        /**
         * @generated from field: qdrant.RenameAlias rename_alias = 2;
         */
        value: RenameAlias;
        case: "renameAlias";
    } | {
        /**
         * @generated from field: qdrant.DeleteAlias delete_alias = 3;
         */
        value: DeleteAlias;
        case: "deleteAlias";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<AliasOperations>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.AliasOperations";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AliasOperations;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AliasOperations;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AliasOperations;
    static equals(a: AliasOperations | PlainMessage<AliasOperations> | undefined, b: AliasOperations | PlainMessage<AliasOperations> | undefined): boolean;
}
/**
 * @generated from message qdrant.CreateAlias
 */
export declare class CreateAlias extends Message<CreateAlias> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * New name of the alias
     *
     * @generated from field: string alias_name = 2;
     */
    aliasName: string;
    constructor(data?: PartialMessage<CreateAlias>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CreateAlias";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateAlias;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateAlias;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateAlias;
    static equals(a: CreateAlias | PlainMessage<CreateAlias> | undefined, b: CreateAlias | PlainMessage<CreateAlias> | undefined): boolean;
}
/**
 * @generated from message qdrant.RenameAlias
 */
export declare class RenameAlias extends Message<RenameAlias> {
    /**
     * Name of the alias to rename
     *
     * @generated from field: string old_alias_name = 1;
     */
    oldAliasName: string;
    /**
     * Name of the alias
     *
     * @generated from field: string new_alias_name = 2;
     */
    newAliasName: string;
    constructor(data?: PartialMessage<RenameAlias>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.RenameAlias";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RenameAlias;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RenameAlias;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RenameAlias;
    static equals(a: RenameAlias | PlainMessage<RenameAlias> | undefined, b: RenameAlias | PlainMessage<RenameAlias> | undefined): boolean;
}
/**
 * @generated from message qdrant.DeleteAlias
 */
export declare class DeleteAlias extends Message<DeleteAlias> {
    /**
     * Name of the alias
     *
     * @generated from field: string alias_name = 1;
     */
    aliasName: string;
    constructor(data?: PartialMessage<DeleteAlias>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DeleteAlias";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteAlias;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteAlias;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteAlias;
    static equals(a: DeleteAlias | PlainMessage<DeleteAlias> | undefined, b: DeleteAlias | PlainMessage<DeleteAlias> | undefined): boolean;
}
/**
 * @generated from message qdrant.ListAliasesRequest
 */
export declare class ListAliasesRequest extends Message<ListAliasesRequest> {
    constructor(data?: PartialMessage<ListAliasesRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ListAliasesRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAliasesRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAliasesRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAliasesRequest;
    static equals(a: ListAliasesRequest | PlainMessage<ListAliasesRequest> | undefined, b: ListAliasesRequest | PlainMessage<ListAliasesRequest> | undefined): boolean;
}
/**
 * @generated from message qdrant.ListCollectionAliasesRequest
 */
export declare class ListCollectionAliasesRequest extends Message<ListCollectionAliasesRequest> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    constructor(data?: PartialMessage<ListCollectionAliasesRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ListCollectionAliasesRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListCollectionAliasesRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListCollectionAliasesRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListCollectionAliasesRequest;
    static equals(a: ListCollectionAliasesRequest | PlainMessage<ListCollectionAliasesRequest> | undefined, b: ListCollectionAliasesRequest | PlainMessage<ListCollectionAliasesRequest> | undefined): boolean;
}
/**
 * @generated from message qdrant.AliasDescription
 */
export declare class AliasDescription extends Message<AliasDescription> {
    /**
     * Name of the alias
     *
     * @generated from field: string alias_name = 1;
     */
    aliasName: string;
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 2;
     */
    collectionName: string;
    constructor(data?: PartialMessage<AliasDescription>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.AliasDescription";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AliasDescription;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AliasDescription;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AliasDescription;
    static equals(a: AliasDescription | PlainMessage<AliasDescription> | undefined, b: AliasDescription | PlainMessage<AliasDescription> | undefined): boolean;
}
/**
 * @generated from message qdrant.ListAliasesResponse
 */
export declare class ListAliasesResponse extends Message<ListAliasesResponse> {
    /**
     * @generated from field: repeated qdrant.AliasDescription aliases = 1;
     */
    aliases: AliasDescription[];
    /**
     * Time spent to process
     *
     * @generated from field: double time = 2;
     */
    time: number;
    constructor(data?: PartialMessage<ListAliasesResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ListAliasesResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAliasesResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAliasesResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAliasesResponse;
    static equals(a: ListAliasesResponse | PlainMessage<ListAliasesResponse> | undefined, b: ListAliasesResponse | PlainMessage<ListAliasesResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.CollectionClusterInfoRequest
 */
export declare class CollectionClusterInfoRequest extends Message<CollectionClusterInfoRequest> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    constructor(data?: PartialMessage<CollectionClusterInfoRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CollectionClusterInfoRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionClusterInfoRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionClusterInfoRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionClusterInfoRequest;
    static equals(a: CollectionClusterInfoRequest | PlainMessage<CollectionClusterInfoRequest> | undefined, b: CollectionClusterInfoRequest | PlainMessage<CollectionClusterInfoRequest> | undefined): boolean;
}
/**
 * @generated from message qdrant.ShardKey
 */
export declare class ShardKey extends Message<ShardKey> {
    /**
     * @generated from oneof qdrant.ShardKey.key
     */
    key: {
        /**
         * String key
         *
         * @generated from field: string keyword = 1;
         */
        value: string;
        case: "keyword";
    } | {
        /**
         * Number key
         *
         * @generated from field: uint64 number = 2;
         */
        value: bigint;
        case: "number";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<ShardKey>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ShardKey";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShardKey;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShardKey;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShardKey;
    static equals(a: ShardKey | PlainMessage<ShardKey> | undefined, b: ShardKey | PlainMessage<ShardKey> | undefined): boolean;
}
/**
 * @generated from message qdrant.LocalShardInfo
 */
export declare class LocalShardInfo extends Message<LocalShardInfo> {
    /**
     * Local shard id
     *
     * @generated from field: uint32 shard_id = 1;
     */
    shardId: number;
    /**
     * Number of points in the shard
     *
     * @generated from field: uint64 points_count = 2;
     */
    pointsCount: bigint;
    /**
     * Is replica active
     *
     * @generated from field: qdrant.ReplicaState state = 3;
     */
    state: ReplicaState;
    /**
     * User-defined shard key
     *
     * @generated from field: optional qdrant.ShardKey shard_key = 4;
     */
    shardKey?: ShardKey;
    constructor(data?: PartialMessage<LocalShardInfo>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.LocalShardInfo";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocalShardInfo;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocalShardInfo;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocalShardInfo;
    static equals(a: LocalShardInfo | PlainMessage<LocalShardInfo> | undefined, b: LocalShardInfo | PlainMessage<LocalShardInfo> | undefined): boolean;
}
/**
 * @generated from message qdrant.RemoteShardInfo
 */
export declare class RemoteShardInfo extends Message<RemoteShardInfo> {
    /**
     * Local shard id
     *
     * @generated from field: uint32 shard_id = 1;
     */
    shardId: number;
    /**
     * Remote peer id
     *
     * @generated from field: uint64 peer_id = 2;
     */
    peerId: bigint;
    /**
     * Is replica active
     *
     * @generated from field: qdrant.ReplicaState state = 3;
     */
    state: ReplicaState;
    /**
     * User-defined shard key
     *
     * @generated from field: optional qdrant.ShardKey shard_key = 4;
     */
    shardKey?: ShardKey;
    constructor(data?: PartialMessage<RemoteShardInfo>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.RemoteShardInfo";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoteShardInfo;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoteShardInfo;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoteShardInfo;
    static equals(a: RemoteShardInfo | PlainMessage<RemoteShardInfo> | undefined, b: RemoteShardInfo | PlainMessage<RemoteShardInfo> | undefined): boolean;
}
/**
 * @generated from message qdrant.ShardTransferInfo
 */
export declare class ShardTransferInfo extends Message<ShardTransferInfo> {
    /**
     * Local shard id
     *
     * @generated from field: uint32 shard_id = 1;
     */
    shardId: number;
    /**
     * @generated from field: optional uint32 to_shard_id = 5;
     */
    toShardId?: number;
    /**
     * @generated from field: uint64 from = 2;
     */
    from: bigint;
    /**
     * @generated from field: uint64 to = 3;
     */
    to: bigint;
    /**
     * If `true` transfer is a synchronization of a replicas; If `false` transfer is a moving of a shard from one peer to another
     *
     * @generated from field: bool sync = 4;
     */
    sync: boolean;
    constructor(data?: PartialMessage<ShardTransferInfo>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ShardTransferInfo";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShardTransferInfo;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShardTransferInfo;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShardTransferInfo;
    static equals(a: ShardTransferInfo | PlainMessage<ShardTransferInfo> | undefined, b: ShardTransferInfo | PlainMessage<ShardTransferInfo> | undefined): boolean;
}
/**
 * @generated from message qdrant.ReshardingInfo
 */
export declare class ReshardingInfo extends Message<ReshardingInfo> {
    /**
     * @generated from field: uint32 shard_id = 1;
     */
    shardId: number;
    /**
     * @generated from field: uint64 peer_id = 2;
     */
    peerId: bigint;
    /**
     * @generated from field: optional qdrant.ShardKey shard_key = 3;
     */
    shardKey?: ShardKey;
    /**
     * @generated from field: qdrant.ReshardingDirection direction = 4;
     */
    direction: ReshardingDirection;
    constructor(data?: PartialMessage<ReshardingInfo>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ReshardingInfo";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReshardingInfo;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReshardingInfo;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReshardingInfo;
    static equals(a: ReshardingInfo | PlainMessage<ReshardingInfo> | undefined, b: ReshardingInfo | PlainMessage<ReshardingInfo> | undefined): boolean;
}
/**
 * @generated from message qdrant.CollectionClusterInfoResponse
 */
export declare class CollectionClusterInfoResponse extends Message<CollectionClusterInfoResponse> {
    /**
     * ID of this peer
     *
     * @generated from field: uint64 peer_id = 1;
     */
    peerId: bigint;
    /**
     * Total number of shards
     *
     * @generated from field: uint64 shard_count = 2;
     */
    shardCount: bigint;
    /**
     * Local shards
     *
     * @generated from field: repeated qdrant.LocalShardInfo local_shards = 3;
     */
    localShards: LocalShardInfo[];
    /**
     * Remote shards
     *
     * @generated from field: repeated qdrant.RemoteShardInfo remote_shards = 4;
     */
    remoteShards: RemoteShardInfo[];
    /**
     * Shard transfers
     *
     * @generated from field: repeated qdrant.ShardTransferInfo shard_transfers = 5;
     */
    shardTransfers: ShardTransferInfo[];
    /**
     * Resharding operations
     *
     * @generated from field: repeated qdrant.ReshardingInfo resharding_operations = 6;
     */
    reshardingOperations: ReshardingInfo[];
    constructor(data?: PartialMessage<CollectionClusterInfoResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CollectionClusterInfoResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionClusterInfoResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionClusterInfoResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionClusterInfoResponse;
    static equals(a: CollectionClusterInfoResponse | PlainMessage<CollectionClusterInfoResponse> | undefined, b: CollectionClusterInfoResponse | PlainMessage<CollectionClusterInfoResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.MoveShard
 */
export declare class MoveShard extends Message<MoveShard> {
    /**
     * Local shard id
     *
     * @generated from field: uint32 shard_id = 1;
     */
    shardId: number;
    /**
     * @generated from field: optional uint32 to_shard_id = 5;
     */
    toShardId?: number;
    /**
     * @generated from field: uint64 from_peer_id = 2;
     */
    fromPeerId: bigint;
    /**
     * @generated from field: uint64 to_peer_id = 3;
     */
    toPeerId: bigint;
    /**
     * @generated from field: optional qdrant.ShardTransferMethod method = 4;
     */
    method?: ShardTransferMethod;
    constructor(data?: PartialMessage<MoveShard>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.MoveShard";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MoveShard;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MoveShard;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MoveShard;
    static equals(a: MoveShard | PlainMessage<MoveShard> | undefined, b: MoveShard | PlainMessage<MoveShard> | undefined): boolean;
}
/**
 * @generated from message qdrant.ReplicateShard
 */
export declare class ReplicateShard extends Message<ReplicateShard> {
    /**
     * Local shard id
     *
     * @generated from field: uint32 shard_id = 1;
     */
    shardId: number;
    /**
     * @generated from field: optional uint32 to_shard_id = 5;
     */
    toShardId?: number;
    /**
     * @generated from field: uint64 from_peer_id = 2;
     */
    fromPeerId: bigint;
    /**
     * @generated from field: uint64 to_peer_id = 3;
     */
    toPeerId: bigint;
    /**
     * @generated from field: optional qdrant.ShardTransferMethod method = 4;
     */
    method?: ShardTransferMethod;
    constructor(data?: PartialMessage<ReplicateShard>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.ReplicateShard";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReplicateShard;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReplicateShard;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReplicateShard;
    static equals(a: ReplicateShard | PlainMessage<ReplicateShard> | undefined, b: ReplicateShard | PlainMessage<ReplicateShard> | undefined): boolean;
}
/**
 * @generated from message qdrant.AbortShardTransfer
 */
export declare class AbortShardTransfer extends Message<AbortShardTransfer> {
    /**
     * Local shard id
     *
     * @generated from field: uint32 shard_id = 1;
     */
    shardId: number;
    /**
     * @generated from field: optional uint32 to_shard_id = 4;
     */
    toShardId?: number;
    /**
     * @generated from field: uint64 from_peer_id = 2;
     */
    fromPeerId: bigint;
    /**
     * @generated from field: uint64 to_peer_id = 3;
     */
    toPeerId: bigint;
    constructor(data?: PartialMessage<AbortShardTransfer>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.AbortShardTransfer";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AbortShardTransfer;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AbortShardTransfer;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AbortShardTransfer;
    static equals(a: AbortShardTransfer | PlainMessage<AbortShardTransfer> | undefined, b: AbortShardTransfer | PlainMessage<AbortShardTransfer> | undefined): boolean;
}
/**
 * @generated from message qdrant.RestartTransfer
 */
export declare class RestartTransfer extends Message<RestartTransfer> {
    /**
     * Local shard id
     *
     * @generated from field: uint32 shard_id = 1;
     */
    shardId: number;
    /**
     * @generated from field: optional uint32 to_shard_id = 5;
     */
    toShardId?: number;
    /**
     * @generated from field: uint64 from_peer_id = 2;
     */
    fromPeerId: bigint;
    /**
     * @generated from field: uint64 to_peer_id = 3;
     */
    toPeerId: bigint;
    /**
     * @generated from field: qdrant.ShardTransferMethod method = 4;
     */
    method: ShardTransferMethod;
    constructor(data?: PartialMessage<RestartTransfer>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.RestartTransfer";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RestartTransfer;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RestartTransfer;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RestartTransfer;
    static equals(a: RestartTransfer | PlainMessage<RestartTransfer> | undefined, b: RestartTransfer | PlainMessage<RestartTransfer> | undefined): boolean;
}
/**
 * @generated from message qdrant.Replica
 */
export declare class Replica extends Message<Replica> {
    /**
     * @generated from field: uint32 shard_id = 1;
     */
    shardId: number;
    /**
     * @generated from field: uint64 peer_id = 2;
     */
    peerId: bigint;
    constructor(data?: PartialMessage<Replica>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.Replica";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Replica;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Replica;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Replica;
    static equals(a: Replica | PlainMessage<Replica> | undefined, b: Replica | PlainMessage<Replica> | undefined): boolean;
}
/**
 * @generated from message qdrant.CreateShardKey
 */
export declare class CreateShardKey extends Message<CreateShardKey> {
    /**
     * User-defined shard key
     *
     * @generated from field: qdrant.ShardKey shard_key = 1;
     */
    shardKey?: ShardKey;
    /**
     * Number of shards to create per shard key
     *
     * @generated from field: optional uint32 shards_number = 2;
     */
    shardsNumber?: number;
    /**
     * Number of replicas of each shard to create
     *
     * @generated from field: optional uint32 replication_factor = 3;
     */
    replicationFactor?: number;
    /**
     * List of peer ids, allowed to create shards. If empty - all peers are allowed
     *
     * @generated from field: repeated uint64 placement = 4;
     */
    placement: bigint[];
    constructor(data?: PartialMessage<CreateShardKey>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CreateShardKey";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateShardKey;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateShardKey;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateShardKey;
    static equals(a: CreateShardKey | PlainMessage<CreateShardKey> | undefined, b: CreateShardKey | PlainMessage<CreateShardKey> | undefined): boolean;
}
/**
 * @generated from message qdrant.DeleteShardKey
 */
export declare class DeleteShardKey extends Message<DeleteShardKey> {
    /**
     * Shard key to delete
     *
     * @generated from field: qdrant.ShardKey shard_key = 1;
     */
    shardKey?: ShardKey;
    constructor(data?: PartialMessage<DeleteShardKey>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DeleteShardKey";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteShardKey;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteShardKey;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteShardKey;
    static equals(a: DeleteShardKey | PlainMessage<DeleteShardKey> | undefined, b: DeleteShardKey | PlainMessage<DeleteShardKey> | undefined): boolean;
}
/**
 * @generated from message qdrant.UpdateCollectionClusterSetupRequest
 */
export declare class UpdateCollectionClusterSetupRequest extends Message<UpdateCollectionClusterSetupRequest> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * @generated from oneof qdrant.UpdateCollectionClusterSetupRequest.operation
     */
    operation: {
        /**
         * @generated from field: qdrant.MoveShard move_shard = 2;
         */
        value: MoveShard;
        case: "moveShard";
    } | {
        /**
         * @generated from field: qdrant.ReplicateShard replicate_shard = 3;
         */
        value: ReplicateShard;
        case: "replicateShard";
    } | {
        /**
         * @generated from field: qdrant.AbortShardTransfer abort_transfer = 4;
         */
        value: AbortShardTransfer;
        case: "abortTransfer";
    } | {
        /**
         * @generated from field: qdrant.Replica drop_replica = 5;
         */
        value: Replica;
        case: "dropReplica";
    } | {
        /**
         * @generated from field: qdrant.CreateShardKey create_shard_key = 7;
         */
        value: CreateShardKey;
        case: "createShardKey";
    } | {
        /**
         * @generated from field: qdrant.DeleteShardKey delete_shard_key = 8;
         */
        value: DeleteShardKey;
        case: "deleteShardKey";
    } | {
        /**
         * @generated from field: qdrant.RestartTransfer restart_transfer = 9;
         */
        value: RestartTransfer;
        case: "restartTransfer";
    } | {
        case: undefined;
        value?: undefined;
    };
    /**
     * Wait timeout for operation commit in seconds, if not specified - default value will be supplied
     *
     * @generated from field: optional uint64 timeout = 6;
     */
    timeout?: bigint;
    constructor(data?: PartialMessage<UpdateCollectionClusterSetupRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.UpdateCollectionClusterSetupRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateCollectionClusterSetupRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateCollectionClusterSetupRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateCollectionClusterSetupRequest;
    static equals(a: UpdateCollectionClusterSetupRequest | PlainMessage<UpdateCollectionClusterSetupRequest> | undefined, b: UpdateCollectionClusterSetupRequest | PlainMessage<UpdateCollectionClusterSetupRequest> | undefined): boolean;
}
/**
 * @generated from message qdrant.UpdateCollectionClusterSetupResponse
 */
export declare class UpdateCollectionClusterSetupResponse extends Message<UpdateCollectionClusterSetupResponse> {
    /**
     * @generated from field: bool result = 1;
     */
    result: boolean;
    constructor(data?: PartialMessage<UpdateCollectionClusterSetupResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.UpdateCollectionClusterSetupResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateCollectionClusterSetupResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateCollectionClusterSetupResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateCollectionClusterSetupResponse;
    static equals(a: UpdateCollectionClusterSetupResponse | PlainMessage<UpdateCollectionClusterSetupResponse> | undefined, b: UpdateCollectionClusterSetupResponse | PlainMessage<UpdateCollectionClusterSetupResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.CreateShardKeyRequest
 */
export declare class CreateShardKeyRequest extends Message<CreateShardKeyRequest> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Request to create shard key
     *
     * @generated from field: qdrant.CreateShardKey request = 2;
     */
    request?: CreateShardKey;
    /**
     * Wait timeout for operation commit in seconds, if not specified - default value will be supplied
     *
     * @generated from field: optional uint64 timeout = 3;
     */
    timeout?: bigint;
    constructor(data?: PartialMessage<CreateShardKeyRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CreateShardKeyRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateShardKeyRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateShardKeyRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateShardKeyRequest;
    static equals(a: CreateShardKeyRequest | PlainMessage<CreateShardKeyRequest> | undefined, b: CreateShardKeyRequest | PlainMessage<CreateShardKeyRequest> | undefined): boolean;
}
/**
 * @generated from message qdrant.DeleteShardKeyRequest
 */
export declare class DeleteShardKeyRequest extends Message<DeleteShardKeyRequest> {
    /**
     * Name of the collection
     *
     * @generated from field: string collection_name = 1;
     */
    collectionName: string;
    /**
     * Request to delete shard key
     *
     * @generated from field: qdrant.DeleteShardKey request = 2;
     */
    request?: DeleteShardKey;
    /**
     * Wait timeout for operation commit in seconds, if not specified - default value will be supplied
     *
     * @generated from field: optional uint64 timeout = 3;
     */
    timeout?: bigint;
    constructor(data?: PartialMessage<DeleteShardKeyRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DeleteShardKeyRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteShardKeyRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteShardKeyRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteShardKeyRequest;
    static equals(a: DeleteShardKeyRequest | PlainMessage<DeleteShardKeyRequest> | undefined, b: DeleteShardKeyRequest | PlainMessage<DeleteShardKeyRequest> | undefined): boolean;
}
/**
 * @generated from message qdrant.CreateShardKeyResponse
 */
export declare class CreateShardKeyResponse extends Message<CreateShardKeyResponse> {
    /**
     * @generated from field: bool result = 1;
     */
    result: boolean;
    constructor(data?: PartialMessage<CreateShardKeyResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.CreateShardKeyResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateShardKeyResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateShardKeyResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateShardKeyResponse;
    static equals(a: CreateShardKeyResponse | PlainMessage<CreateShardKeyResponse> | undefined, b: CreateShardKeyResponse | PlainMessage<CreateShardKeyResponse> | undefined): boolean;
}
/**
 * @generated from message qdrant.DeleteShardKeyResponse
 */
export declare class DeleteShardKeyResponse extends Message<DeleteShardKeyResponse> {
    /**
     * @generated from field: bool result = 1;
     */
    result: boolean;
    constructor(data?: PartialMessage<DeleteShardKeyResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "qdrant.DeleteShardKeyResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteShardKeyResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteShardKeyResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteShardKeyResponse;
    static equals(a: DeleteShardKeyResponse | PlainMessage<DeleteShardKeyResponse> | undefined, b: DeleteShardKeyResponse | PlainMessage<DeleteShardKeyResponse> | undefined): boolean;
}
