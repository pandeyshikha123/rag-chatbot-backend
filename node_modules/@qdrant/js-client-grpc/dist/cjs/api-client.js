"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createApis = void 0;
const connect_1 = require("@bufbuild/connect");
const connect_node_1 = require("@bufbuild/connect-node");
const collections_service_connect_js_1 = require("./proto/collections_service_connect.js");
const points_service_connect_js_1 = require("./proto/points_service_connect.js");
const snapshots_service_connect_js_1 = require("./proto/snapshots_service_connect.js");
const qdrant_connect_js_1 = require("./proto/qdrant_connect.js");
const client_version_js_1 = require("./client-version.js");
const errors_js_1 = require("./errors.js");
function createClients(transport) {
    let collections;
    let points;
    let snapshots;
    let service;
    return {
        get collections() {
            if (!collections) {
                collections = (0, connect_1.createPromiseClient)(collections_service_connect_js_1.Collections, transport);
            }
            return collections;
        },
        get points() {
            if (!points) {
                points = (0, connect_1.createPromiseClient)(points_service_connect_js_1.Points, transport);
            }
            return points;
        },
        get snapshots() {
            if (!snapshots) {
                snapshots = (0, connect_1.createPromiseClient)(snapshots_service_connect_js_1.Snapshots, transport);
            }
            return snapshots;
        },
        get service() {
            if (!service) {
                service = (0, connect_1.createPromiseClient)(qdrant_connect_js_1.Qdrant, transport);
            }
            return service;
        },
    };
}
function createApis(baseUrl, { timeout, apiKey }) {
    const interceptors = [
        (next) => (req) => {
            req.header.set('user-agent', 'qdrant-js/' + String(client_version_js_1.PACKAGE_VERSION));
            return next(req);
        },
        (next) => (req) => next(req).catch((error) => {
            if (error instanceof connect_1.ConnectError && error.code === connect_1.Code.ResourceExhausted) {
                const retryAfterHeader = error.metadata.get('retry-after')?.[0];
                if (retryAfterHeader) {
                    throw new errors_js_1.QdrantClientResourceExhaustedError(error.rawMessage, retryAfterHeader);
                }
            }
            throw error;
        }),
    ];
    if (apiKey !== undefined) {
        interceptors.push((next) => (req) => {
            req.header.set('api-key', apiKey);
            return next(req);
        });
    }
    if (Number.isFinite(timeout)) {
        interceptors.push((next) => async (req) => {
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeout);
            try {
                return await next(Object.assign(req, { signal: controller.signal }));
            }
            finally {
                clearTimeout(id);
            }
        });
    }
    const transport = (0, connect_node_1.createGrpcTransport)({
        baseUrl,
        httpVersion: '2',
        keepSessionAlive: true,
        useBinaryFormat: true,
        sendCompression: connect_node_1.compressionGzip,
        acceptCompression: [connect_node_1.compressionGzip],
        interceptors,
    });
    return createClients(transport);
}
exports.createApis = createApis;
