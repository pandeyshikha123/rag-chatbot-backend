"use strict";
// @generated by protoc-gen-connect-es v0.10.0 with parameter "target=ts"
// @generated from file points_service.proto (package qdrant, syntax proto3)
/* eslint-disable */
// @ts-nocheck
Object.defineProperty(exports, "__esModule", { value: true });
exports.Points = void 0;
const points_pb_js_1 = require("./points_pb.js");
const protobuf_1 = require("@bufbuild/protobuf");
/**
 * @generated from service qdrant.Points
 */
exports.Points = {
    typeName: "qdrant.Points",
    methods: {
        /**
         *
         * Perform insert + updates on points. If a point with a given ID already exists - it will be overwritten.
         *
         * @generated from rpc qdrant.Points.Upsert
         */
        upsert: {
            name: "Upsert",
            I: points_pb_js_1.UpsertPoints,
            O: points_pb_js_1.PointsOperationResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Delete points
         *
         * @generated from rpc qdrant.Points.Delete
         */
        delete: {
            name: "Delete",
            I: points_pb_js_1.DeletePoints,
            O: points_pb_js_1.PointsOperationResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Retrieve points
         *
         * @generated from rpc qdrant.Points.Get
         */
        get: {
            name: "Get",
            I: points_pb_js_1.GetPoints,
            O: points_pb_js_1.GetResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Update named vectors for point
         *
         * @generated from rpc qdrant.Points.UpdateVectors
         */
        updateVectors: {
            name: "UpdateVectors",
            I: points_pb_js_1.UpdatePointVectors,
            O: points_pb_js_1.PointsOperationResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Delete named vectors for points
         *
         * @generated from rpc qdrant.Points.DeleteVectors
         */
        deleteVectors: {
            name: "DeleteVectors",
            I: points_pb_js_1.DeletePointVectors,
            O: points_pb_js_1.PointsOperationResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Set payload for points
         *
         * @generated from rpc qdrant.Points.SetPayload
         */
        setPayload: {
            name: "SetPayload",
            I: points_pb_js_1.SetPayloadPoints,
            O: points_pb_js_1.PointsOperationResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Overwrite payload for points
         *
         * @generated from rpc qdrant.Points.OverwritePayload
         */
        overwritePayload: {
            name: "OverwritePayload",
            I: points_pb_js_1.SetPayloadPoints,
            O: points_pb_js_1.PointsOperationResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Delete specified key payload for points
         *
         * @generated from rpc qdrant.Points.DeletePayload
         */
        deletePayload: {
            name: "DeletePayload",
            I: points_pb_js_1.DeletePayloadPoints,
            O: points_pb_js_1.PointsOperationResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Remove all payload for specified points
         *
         * @generated from rpc qdrant.Points.ClearPayload
         */
        clearPayload: {
            name: "ClearPayload",
            I: points_pb_js_1.ClearPayloadPoints,
            O: points_pb_js_1.PointsOperationResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Create index for field in collection
         *
         * @generated from rpc qdrant.Points.CreateFieldIndex
         */
        createFieldIndex: {
            name: "CreateFieldIndex",
            I: points_pb_js_1.CreateFieldIndexCollection,
            O: points_pb_js_1.PointsOperationResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Delete field index for collection
         *
         * @generated from rpc qdrant.Points.DeleteFieldIndex
         */
        deleteFieldIndex: {
            name: "DeleteFieldIndex",
            I: points_pb_js_1.DeleteFieldIndexCollection,
            O: points_pb_js_1.PointsOperationResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Retrieve closest points based on vector similarity and given filtering conditions
         *
         * @generated from rpc qdrant.Points.Search
         */
        search: {
            name: "Search",
            I: points_pb_js_1.SearchPoints,
            O: points_pb_js_1.SearchResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Retrieve closest points based on vector similarity and given filtering conditions
         *
         * @generated from rpc qdrant.Points.SearchBatch
         */
        searchBatch: {
            name: "SearchBatch",
            I: points_pb_js_1.SearchBatchPoints,
            O: points_pb_js_1.SearchBatchResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Retrieve closest points based on vector similarity and given filtering conditions, grouped by a given field
         *
         * @generated from rpc qdrant.Points.SearchGroups
         */
        searchGroups: {
            name: "SearchGroups",
            I: points_pb_js_1.SearchPointGroups,
            O: points_pb_js_1.SearchGroupsResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Iterate over all or filtered points
         *
         * @generated from rpc qdrant.Points.Scroll
         */
        scroll: {
            name: "Scroll",
            I: points_pb_js_1.ScrollPoints,
            O: points_pb_js_1.ScrollResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Look for the points which are closer to stored positive examples and at the same time further to negative examples.
         *
         * @generated from rpc qdrant.Points.Recommend
         */
        recommend: {
            name: "Recommend",
            I: points_pb_js_1.RecommendPoints,
            O: points_pb_js_1.RecommendResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Look for the points which are closer to stored positive examples and at the same time further to negative examples.
         *
         * @generated from rpc qdrant.Points.RecommendBatch
         */
        recommendBatch: {
            name: "RecommendBatch",
            I: points_pb_js_1.RecommendBatchPoints,
            O: points_pb_js_1.RecommendBatchResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Look for the points which are closer to stored positive examples and at the same time further to negative examples, grouped by a given field
         *
         * @generated from rpc qdrant.Points.RecommendGroups
         */
        recommendGroups: {
            name: "RecommendGroups",
            I: points_pb_js_1.RecommendPointGroups,
            O: points_pb_js_1.RecommendGroupsResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Use context and a target to find the most similar points to the target, constrained by the context.
         *
         * When using only the context (without a target), a special search - called context search - is performed where
         * pairs of points are used to generate a loss that guides the search towards the zone where
         * most positive examples overlap. This means that the score minimizes the scenario of
         * finding a point closer to a negative than to a positive part of a pair.
         *
         * Since the score of a context relates to loss, the maximum score a point can get is 0.0,
         * and it becomes normal that many points can have a score of 0.0.
         *
         * When using target (with or without context), the score behaves a little different: The
         * integer part of the score represents the rank with respect to the context, while the
         * decimal part of the score relates to the distance to the target. The context part of the score for
         * each pair is calculated +1 if the point is closer to a positive than to a negative part of a pair,
         * and -1 otherwise.
         *
         * @generated from rpc qdrant.Points.Discover
         */
        discover: {
            name: "Discover",
            I: points_pb_js_1.DiscoverPoints,
            O: points_pb_js_1.DiscoverResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Batch request points based on { positive, negative } pairs of examples, and/or a target
         *
         * @generated from rpc qdrant.Points.DiscoverBatch
         */
        discoverBatch: {
            name: "DiscoverBatch",
            I: points_pb_js_1.DiscoverBatchPoints,
            O: points_pb_js_1.DiscoverBatchResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Count points in collection with given filtering conditions
         *
         * @generated from rpc qdrant.Points.Count
         */
        count: {
            name: "Count",
            I: points_pb_js_1.CountPoints,
            O: points_pb_js_1.CountResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Perform multiple update operations in one request
         *
         * @generated from rpc qdrant.Points.UpdateBatch
         */
        updateBatch: {
            name: "UpdateBatch",
            I: points_pb_js_1.UpdateBatchPoints,
            O: points_pb_js_1.UpdateBatchResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Universally query points. This endpoint covers all capabilities of search, recommend, discover, filters. But also enables hybrid and multi-stage queries.
         *
         * @generated from rpc qdrant.Points.Query
         */
        query: {
            name: "Query",
            I: points_pb_js_1.QueryPoints,
            O: points_pb_js_1.QueryResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Universally query points in a batch fashion. This endpoint covers all capabilities of search, recommend, discover, filters. But also enables hybrid and multi-stage queries.
         *
         * @generated from rpc qdrant.Points.QueryBatch
         */
        queryBatch: {
            name: "QueryBatch",
            I: points_pb_js_1.QueryBatchPoints,
            O: points_pb_js_1.QueryBatchResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Universally query points in a group fashion. This endpoint covers all capabilities of search, recommend, discover, filters. But also enables hybrid and multi-stage queries.
         *
         * @generated from rpc qdrant.Points.QueryGroups
         */
        queryGroups: {
            name: "QueryGroups",
            I: points_pb_js_1.QueryPointGroups,
            O: points_pb_js_1.QueryGroupsResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Perform facet counts. For each value in the field, count the number of points that have this value and match the conditions.
         *
         * @generated from rpc qdrant.Points.Facet
         */
        facet: {
            name: "Facet",
            I: points_pb_js_1.FacetCounts,
            O: points_pb_js_1.FacetResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Compute distance matrix for sampled points with a pair based output format
         *
         * @generated from rpc qdrant.Points.SearchMatrixPairs
         */
        searchMatrixPairs: {
            name: "SearchMatrixPairs",
            I: points_pb_js_1.SearchMatrixPoints,
            O: points_pb_js_1.SearchMatrixPairsResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
        /**
         *
         * Compute distance matrix for sampled points with an offset based output format
         *
         * @generated from rpc qdrant.Points.SearchMatrixOffsets
         */
        searchMatrixOffsets: {
            name: "SearchMatrixOffsets",
            I: points_pb_js_1.SearchMatrixPoints,
            O: points_pb_js_1.SearchMatrixOffsetsResponse,
            kind: protobuf_1.MethodKind.Unary,
        },
    }
};
